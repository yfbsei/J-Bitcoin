Shared Secrets and Threshold
Signatures

Reference Document
Michaella Pettit

Shared Secrets and Threshold Signatures

Copyright
This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International
License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.
The names of actual companies and products mentioned in this document may be trademarks of
their respective owners.
nChain Limited accepts no responsibility or liability f or any errors or inaccuracies that may appear
in this documentation.

Page i

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

Contents
1

Introduction............................................................................................................... 1

2

Secret sharing .......................................................................................................... 2
2.1

Joint Verif iable Random Secret Sharing ........................................................................... 2

2.2

Addition of shared secrets ............................................................................................... 5

2.3

Product of shared secrets ................................................................................................ 6

2.4

Inverse of a shared secret ............................................................................................... 6

3

Secret sharing worked example .......................................................................... 8
3.1

Joint Verif iable Random Secret Sharing ........................................................................... 8

3.2

Addition of shared secrets ..............................................................................................10

3.3

Product of shared secrets ...............................................................................................12

3.4

Inverse of a shared secret ..............................................................................................13

4

Threshold signatures ...........................................................................................15
4.1

Shared private key generation and verif ication .................................................................16

4.2

Ephemeral key shares generation ...................................................................................16

4.3

Signature generation ......................................................................................................16

5

Threshold signatures worked example ...........................................................18
5.1

Shared private key generation and verif ication .................................................................18

5.2

Ephemeral key shares generation ...................................................................................18

5.3

Signature generation ......................................................................................................18

6

Page ii

References ..............................................................................................................20

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

1

Introduction
In the f ollowing document we describe how to create and verif y a shared secret between ğ‘
participants without a single entity knowing the secret. We show how to calculate the addition and
multiplication of two shared secrets, and how to calculate shares of the inverse of a shared secret.
We begin by describing these concepts f or a general number of participants and then go through a
worked example with just three participants to illustrate the ideas in a more digestible way.
We then explore a specif ic use case: a threshold signature scheme in which participants must
cooperate to create a signature on a message. Again, we describe the signature scheme f or a
general number of participants and then go through a worked example.
The threshold signature scheme described below allows digital signatures to be created without the
private key ever coming into existence. It is so-called â€˜threshold non-optimalâ€™ meaning that the
number of shares required to recreate the shared secret is less than the number of shares required
to create a signature. However, this can be usef ul if one of the shares is lost as the shared key is
still recoverable. It is also computationally f ast and practical to implement.
The scheme exploits some usef ul mathematical properties of polynomials. One key f act that is
used is there is a unique polynomial curve of order ğ‘¡ that passes through (ğ‘¡ + 1) points. This
means that given any selection of (ğ‘¡ + 1) points on a polynomial curve of order ğ‘¡ it is possible to
identif y the underlying polynomial, and in turn identif y a unique shared secret.
The polynomials we work with are over the f inite f ield â„¤ğ‘› where ğ‘› is prime and is related to the
order of an elliptic curve group.
Elliptic curve groups
An elliptic curve ğ¸ satisf ies the equation
ğ‘¦ 2 = ğ‘¥ 3 + ğ‘ğ‘¥ + ğ‘ mod ğ‘ ,
where ğ‘, ğ‘ âˆˆ â„¤ğ‘ and ğ‘, ğ‘ are constants satisf ying 4ğ‘3 + 27ğ‘3 â‰  0. We only consider elliptic curves
where ğ‘ is a prime. The group over this elliptic curve is then def ined to be the set of elements (ğ‘¥, ğ‘¦)
satisf ying this equation along with the point at inf inity ğ’ª, which is the identity element. The group
operation on the elements in this group is called elliptic curve point addition and denoted by +. We
denote this group by ğ¸(â„¤ğ‘ ) and its order by ğ‘›.
This group operation can be used to def ine another operation on the elements called point
multiplication denoted by â‹…. For a point ğº âˆˆ ğ¸(â„¤ğ‘ ) and a scalar ğ‘˜ âˆˆ â„¤âˆ—ğ‘›, the point ğ‘˜ â‹… ğº is def ined to
be the point ğº added to itself ğ‘˜ times. The explicit f orm of point addition is not necessary here, so
we ref er the reader to one of the many elliptic curve group resources f or more inf ormation if
required.
In Elliptic Curve Cryptography a private key is def ined to be a scalar ğ‘˜ âˆˆ â„¤âˆ—ğ‘› , and the corresponding
public key is the point ğ‘˜ â‹… ğº on an elliptic curve. In Bitcoin, this was chosen to be the secp256k1
elliptic curve, and the values ğ‘, ğ‘, and ğ‘ are completely specif ied by this curve. The order ğ‘› of this
group has been calculated given these values, which in the case of this curve is a prime, and the
secp256k1 standard specif ies a point ğº which is to be used as the generator of this group in
Bitcoin. Given a point ğ‘˜ â‹… ğº on the secp256k1 curve, it is computationally inf easible to calculate ğ‘˜,
which is one of the reasons behind why Bitcoin is secure.

Page 1

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

2

Secret sharing
In this section we describe how to create a shared secret and verif y that all participants are sharing
the correct inf ormation in the set-up. This is conventionally known as Joint Verif iable Random
Secret Sharing. We then show how to calculate the addition and product of two shared, and then
how to calculate the shares of the inverse of a shared secret.

2.1

Joint Verifiable Random Secret Sharing
To create a shared secret between ğ‘ participants a method called Joint Verif iable Random Secret
Sharing (JVRSS) is used, introduced by Pedersen [1]. Assume that ğ‘ participants want to create a
joint secret that can only be regenerated by at least (ğ‘¡ + 1) of the participants in the scheme. This
restricts (ğ‘¡ + 1) â‰¤ ğ‘ as otherwise it will not be possible to calculate the shared secret. Any attempts
to regenerate the secret by less than (ğ‘¡ + 1) participants will be unsuccessf ul. To create the shared
secret, the f ollowing steps are taken.
1.

2.

3.

The participants agree on the unique label ğ‘– f or each participant. Each participant ğ‘– generates
ğ‘¡ + 1 random numbers
ğ‘ğ‘–ğ‘— âˆˆ ğ‘… â„¤âˆ—ğ‘› , âˆ€ğ‘— = 0, â€¦ , ğ‘¡ ,
where âˆˆğ‘… means a randomly generated element of the f ield â„¤ğ‘› . Then each participant has a
secret polynomial of order ğ‘¡
ğ‘“ğ‘– (ğ‘¥) = ğ‘ğ‘–0 + ğ‘ğ‘–1 ğ‘¥ + â‹¯ + ğ‘ğ‘–ğ‘¡ ğ‘¥ ğ‘¡ mod ğ‘› ,
f or ğ‘– = 1, â€¦ , ğ‘. The ğ‘ participants of the group use these polynomials to generate a shared
secret polynomial, where the sum of the zeroth-order of the private polynomials ğ‘ğ‘–0 is the
shared secret. Note that we omit the mod ğ‘› notation f rom now on, and it is assumed that all
arithmetic operations over integers are done modulo ğ‘›.
Each participant ğ‘– sends the value ğ‘“ğ‘– (ğ‘—) to participant ğ‘— using a secure communication channel
with participant ğ‘— only. It is crucial that ğ‘“ğ‘– (ğ‘—) is shared only with participant ğ‘—. If the value ğ‘“ğ‘– (ğ‘—) is
shared with all participants f or more than ğ‘¡ dif ferent values of ğ‘—, then it is possible f or all
participants to calculate the private polynomial of participant ğ‘–. If all private polynomials are
able to be calculated, then the shared secret polynomial is all calculable.
Each participant ğ‘– calculates their own private secret share of a shared secret polynomial as
ğ‘

ğ‘ğ‘– â‰” âˆ‘ ğ‘“ğ‘— (ğ‘–) .
ğ‘—=1

These secret shares are ğ‘¦-values on the shared polynomial. Essentially, by def ining the shares
in this way, the shared polynomial is being def ined as
ğ‘

ğ‘“ (ğ‘¥) â‰” âˆ‘ ğ‘“ğ‘– (ğ‘¥) .
ğ‘– =1

Of course, no participant knows this polynomial explicitly.
The shared secret ğ‘ is then the zeroth-order of the shared polynomial
ğ‘

ğ‘

ğ‘ â‰” ğ‘“ (0) = âˆ‘ ğ‘“ğ‘– (0) = âˆ‘ ğ‘ğ‘–0 ,
ğ‘–=1

ğ‘–=1

that is, the sum of the zeroth-order terms of the private polynomials of the participants. Again,
no single participant knows this shared polynomial or secret; they only know their own share ğ‘ğ‘– .
Now that the participants have generated a shared polynomial, they can each verif y that the other
participants have shared the correct inf ormation to all participants , and that all participants have the
same shared polynomial. This is done in the f ollowing way.
4.

Page 2

Each participant ğ‘– broadcasts to all participants the obf uscated coefficients

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

5.

ğ‘ğ‘–ğ‘˜ â‹… ğº ,
f or ğ‘˜ = 0, â€¦ , ğ‘¡. It is important to broadcast this so that each participant knows that other
participants got the same inf ormation.
Each participant ğ‘– can check that each participant ğ‘— has correctly calculated the polynomial
point ğ‘“ğ‘— (ğ‘– ) . This is done by calculating the public key corresponding to the polynomial point of
participant ğ‘— and compare this to the obf uscated coefficients ğ‘ğ‘—ğ‘˜ â‹… ğº where ğ‘˜ = 0, â€¦ , ğ‘¡. That is,
participant ğ‘– calculates ğ‘“ğ‘— (ğ‘–) â‹… ğº and checks that
ğ‘¡

ğ‘“ğ‘— (ğ‘–) â‹… ğº â‰Ÿ âˆ‘ ğ‘– ğ‘˜ (ğ‘ğ‘—ğ‘˜ â‹… ğº )

âˆ€ ğ‘— = 1, â€¦ , ğ‘ .

ğ‘˜=0

If any of the participants f ind that this equality doesnâ€™t hold, they raise an issue and the adversary
can be removed f rom the group. On the other hand, if all participants f ind that this equation holds
f or each polynomial, then these obf uscated coefficients necessarily correspond to the private
polynomial point shared by a participant. The group collectively can then be sure that they have all
created the same shared polynomial.
This completes the derivation and verif ication of shared secret shares. Note that the shared secret
shares correspond to the ğ‘¦-value of a point on a shared polynomial, and a participantâ€™s index ğ‘–
corresponds to the ğ‘¥-value at that point. That is, a shared secret share is a point with the f orm
(ğ‘–, ğ‘ğ‘– ), where ğ‘– is the participants label in the scheme. As mentioned, it is important that all
participants agree on the label of each participant.
We denote the method described in steps 1-5 by ğ‘ğ‘– = ğ½ğ‘‰ğ‘…ğ‘†ğ‘† (ğ‘–) f or participant ğ‘–.
Reconstructing a shared secret: Lagrange Interpolation
In order to reconstruct a shared secret Lagrange interpolation is used. Lagrange interpolation is a
method describing how to calculate an order-ğ‘¡ polynomial, given (ğ‘¡ + 1) points on that polynomial.
Assume we want to reconstruct an order-ğ‘¡ polynomial ğ‘“(ğ‘¥) . One requires knowledge of at least
(ğ‘¡ + 1) points on this polynomial to reconstruct it. If we label these points by
(ğ‘¥ 1 , ğ‘¦1 ), â€¦ , ( ğ‘¥ ğ‘¡+1 , ğ‘¦ğ‘¡ +1 ) ,
then to f ind the polynomial, one calculates
ğ‘¡ +1

ğ‘“ (ğ‘¥) =

âˆ‘ ğ‘¦ğ‘™
ğ‘™ =1

(

âˆ

( ğ‘¥ âˆ’ ğ‘¥ğ‘— ) ( ğ‘¥ ğ‘™ âˆ’ ğ‘¥ğ‘— )

âˆ’1

1â‰¤ğ‘—â‰¤ (ğ‘¡+1) ,
ğ‘—â‰  ğ‘™

.
)

Note that with less than (ğ‘¡ + 1) points it is not possible to f ind a unique polynomial. If one
interpolates over more than (ğ‘¡ + 1) shares, the result is the same as interpolating over exactly (ğ‘¡ +
1) shares. However, if one interpolates over more than (ğ‘¡ + 1) shares, and there is a mistake in
any of the shares, the interpolation result will be wrong, even if (ğ‘¡ + 1) of the shares are correct.
In order to f ind the zeroth order coef f icient of the polynomial, the equation is simplif ied to
ğ‘¡ +1

ğ‘“ (0) =

âˆ‘ ğ‘¦ğ‘™
ğ‘™=1

(

âˆ

(âˆ’ğ‘¥ğ‘— ) (ğ‘¥ ğ‘™ âˆ’ ğ‘¥ğ‘— )

1â‰¤ğ‘—â‰¤ (ğ‘¡+1),
ğ‘—â‰  ğ‘™

âˆ’1

.
)

Recall that the shared secret is def ined as the zeroth order coef f icient of the polynomial, and so
this equation calculates the shared secret.

Page 3

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
We denote interpolation at 0 by ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ( ğ‘1 , â€¦ , ğ‘ğ‘¡ +1 ), where ğ‘ğ‘– is the secret share of participant
ğ‘– f or ğ‘– = 1, â€¦ , (ğ‘¡ + 1). That is, we def ine
ğ‘¡ +1

ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ( ğ‘1 , â€¦ , ğ‘ğ‘¡ +1 ) â‰”

âˆ‘ ğ‘ğ‘–
ğ‘– =1

(

âˆ

(âˆ’ğ‘—) (ğ‘– âˆ’ ğ‘—) âˆ’1

1â‰¤ğ‘—â‰¤ (ğ‘¡+1) ,
ğ‘—â‰  ğ‘–

.
)

Notice that this is interpolation evaluated at zero, such that the result of the calculation is the
shared secret that has been shared using JVRSS.
We now give two methods that allow us to calculate the shared public key corresponding to a
shared secret that has been calculated with JVRSS.
JVRSS public key calculation method 1: Elliptic curve interpolation
If one would like to calculate a public key corresponding to a shared secret, it can be calculated
using elliptic curve (EC) Lagrange interpolation. In this case, the points are of the f orm
(ğ‘¥ 1 , ğ‘¦1 â‹… ğº ) , â€¦ , (ğ‘¥ ğ‘¡+1 , ğ‘¦ğ‘¡ +1 â‹… ğº ) ,
where ğ‘¦1 , â€¦ , ğ‘¦ğ‘¡ +1 are the shares on the shared secret polynomial, as bef ore, and ğ‘¦1 â‹… ğº, â€¦ , ğ‘¦ğ‘¡ +1 â‹… ğº
are the corresponding public keys. Then the public key of the shared polynomial is reconstructed
using
ğ‘¡ +1

ğ‘“ (ğ‘¥) â‹… ğº = âˆ‘ ğ‘¦ğ‘™ â‹… ğº

âˆ

(ğ‘¥ âˆ’ ğ‘¥ğ‘— )(ğ‘¥ ğ‘™ âˆ’ ğ‘¥ğ‘— )

âˆ’1

,

1â‰¤ğ‘—â‰¤ (ğ‘¡+1) ,
ğ‘—â‰  ğ‘™

ğ‘™ =1

where the summation is elliptic curve point addition and the product is integer multiplication modulo
ğ‘›. Alternatively, to immediately f ind the shared secret, the equation simplif ies to
ğ‘¡+1

ğ‘“ (0) â‹… ğº = âˆ‘ ğ‘¦ğ‘™ â‹… ğº
ğ‘™=1

âˆ

(âˆ’ğ‘¥ğ‘— )(ğ‘¥ğ‘™ âˆ’ ğ‘¥ğ‘— )

âˆ’1

.

1â‰¤ğ‘—â‰¤ (ğ‘¡+1) ,
ğ‘—â‰  ğ‘™

This is the usual way to calculate a public key corresponding to a shared secret and can be
executed f or any shared values in the f orm of an EC point. However, if JVRSS has been executed,
we can use inf ormation f rom this to calculate a public key corresponding to a shared secret in a
more ef f icient way. We describe this alternative method.
JVRSS public key calculation method 2: Simple point addition of the zeroth order
coefficients
In step 4 of JVRSS the public keys corresponding to private polynomial coef ficients are shared. In
order to calculate the public key corresponding to a shared secret, one can simply add the zeroth order private polynomial coef ficient public keys, and this gives the public key corresponding to the
shared secret. That is, given the ğ‘ zeroth-order private polynomial coef f icient public keys ğ‘ğ‘–0 â‹… ğº f or
ğ‘– = 1, â€¦ , ğ‘ , the equation f or the shared public key is
ğ‘

ğ‘ â‹… ğº = âˆ‘ ğ‘ğ‘–0 â‹… ğº ,
ğ‘– =1

where ğ‘ â‹… ğº is the public key corresponding to the shared secret ğ‘. By calculating the public key
corresponding to a shared secret by adding the zeroth-order coef f icients explicitly, there are exactly
ğ‘ âˆ’ 1 point additions to calculate.

Page 4

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
This summation is equivalent to interpolation over the elliptic curve points ğ‘ğ‘– â‹… ğº, where the shared
secret shares are ğ‘ğ‘– . We can attempt to compare this summation to the number of additions in EC
interpolation given by the equation f or ğ‘“ (0) â‹… ğº above.
We see immediately that there are ğ‘¡ point additions that must be done with the overall summation.
However, because of the product coef ficient f or each term, there are more additions that must be
done corresponding to scalar point multiplication. For each ğ‘¦ğ‘™ â‹… ğº, the coef f icient is
âˆ

ğ‘ğ‘™ =

(âˆ’ğ‘¥ğ‘— )(ğ‘¥ ğ‘™ âˆ’ ğ‘¥ğ‘— )

âˆ’1

.

1â‰¤ğ‘—â‰¤ (ğ‘¡+1),
ğ‘—â‰  ğ‘™

It is very dif f icult to simplify these coef ficients without knowing or making assumptions about the
explicit values of ğ‘¥ğ‘— , ğ‘¥ ğ‘™. Note that some of these will be negative coef f icients, or equivalently
(ğ‘› âˆ’ ğ‘ğ‘™ ) mod ğ‘›, which we can assume to be large, as we choose ğ‘¥ ğ‘˜ = ğ‘˜ â‰ª ğ‘›.
Additionally, in the case of the shared public key calculation, each ğ‘¦ğ‘™ â‹… ğº needs to initially be
calculated, since ğ‘ğ‘– â‹… ğº is not shared explicitly. This is done by calculating
ğ‘

ğ‘ğ‘– â‹… ğº = âˆ‘ ğ‘“ğ‘— (ğ‘– ) â‹… ğº ,
ğ‘— =1

f or each ğ‘– = 1, â€¦ , ğ‘ . This implies that in total at least
(ğ‘ âˆ’ 1)ğ‘ğ‘¡
point additions must be calculated in EC interpolation to calculate the public key of a shared secret
given JVRSS. In addition to this, the modular inverse is costly, and is calculated ğ‘¡(ğ‘¡ + 1) times in
an interpolation. Since each participant does these calculations, the group as a whole does this
number of calculations ğ‘ times.
With all this in mind, method 2 would generally be the best method of calculating a shared public
key. However, there may be some cases, such as when ğ‘¦ğ‘™ â‹… ğº is known and ğ‘ â‰« ğ‘¡, where elliptic
curve interpolation could be pref erable.

2.2

Addition of shared secrets
We describe how to calculate the addition of two shared secrets that are shared amongst a group
of ğ‘ participants, where each secret polynomial has order ğ‘¡. This method allows f or the calculation
of the addition of two shared secrets by the group without a single entity knowing either of the
shared secrets. The general process f or this is as f ollows.
1.

2.
3.
4.
5.

Page 5

Generate the f irst shared secret ğ‘, where participant ğ‘–â€™s share is given by ğ‘ğ‘– = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(ğ‘–) f or ğ‘– =
1, â€¦ , ğ‘ where ğ‘ is the number of participants in the scheme. The shared secret polynomial has
order ğ‘¡, meaning (ğ‘¡ + 1) participants are required to recreate it.
Generate the second shared secret ğ‘, where participant ğ‘–â€™s share is given by ğ‘ğ‘– = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(ğ‘–),
and the shared secret polynomial again has order ğ‘¡.
Each participant calculates their own additive share
ğœˆğ‘– = ğ‘ğ‘– + ğ‘ğ‘– mod ğ‘› .
All participants broadcast their additive share ğœˆğ‘– to all other participants. It is saf e f or these
shares to be shared publicly.
Each participant interpolates over at least (ğ‘¡ + 1) of the shares ğœˆğ‘– to calculate
ğœˆ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ (ğœˆ1 , â€¦ , ğœˆğ‘¡+1 ) = ğ‘ + ğ‘ .
Note that interpolation can be done over more than (ğ‘¡ + 1) shares, and the result will still be
the same provided all shares in the interpolation are correct.

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
We denote the steps in addition of shared secrets f or participant ğ‘– by ğ´ğ·ğ·ğ‘†ğ‘† (ğ‘–) which results in
each participant ğ‘– knowing ğœˆ = (ğ‘ + ğ‘).

2.3

Product of shared secrets
We describe how to calculate the product of two shared secrets that are both shared amongst a
group of ğ‘ participants, where each secret polynomial has order ğ‘¡. This method allows f or the
calculation of the product of two shared secrets by the group without a single entity knowing either
of the shared secrets. The general process f or this is as f ollows.
1.

2.
3.

4.
5.

Generate the f irst shared secret ğ‘, where participant ğ‘–â€™s share is given by ğ‘ğ‘– = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(ğ‘–) f or ğ‘– =
1, â€¦ , ğ‘ where ğ‘ is the number of participants in the scheme. The shared secret polynomial has
order ğ‘¡, meaning (ğ‘¡ + 1) participants are required to recreate it.
Generate the second shared secret ğ‘, where participant ğ‘–â€™s share is given by ğ‘ğ‘– = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(ğ‘–),
and the shared secret polynomial again has order ğ‘¡.
Each participant calculates their own multiplicative share ğœ‡ ğ‘– using
ğœ‡ ğ‘– = ğ‘ğ‘– ğ‘ğ‘– .
These are the ğ‘¦-values on a shared polynomial of order 2ğ‘¡ at ğ‘¥ = ğ‘–, and this polynomial
necessarily crosses the ğ‘¦-axis at ğ‘ğ‘. Since the polynomial has order 2ğ‘¡, at least 2ğ‘¡ + 1
participants are required to calculate the multiplicative value at the point ğ‘¥ = 0, which results in
ğ‘ğ‘.
All participants broadcast their multiplicative share ğœ‡ ğ‘– to all other participants. It is saf e f or these
shares to be shared publicly.
Each participant interpolates over at least (2ğ‘¡ + 1) of the shares ğœ‡ ğ‘– at 0 to calculate
ğœ‡ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ( ğœ‡ 1 , â€¦ , ğœ‡ 2ğ‘¡+1 ) = ğ‘ğ‘ .
Again, interpolation can be done over more than (2ğ‘¡ + 1) shares, and the result will still be the
same provided all shares in the interpolation are correct.

We denote the steps f or participant ğ‘– in the product of shared secrets by ğœ‡ = ğ‘ğ‘ = ğ‘ƒğ‘…ğ‘‚ğ‘†ğ‘†(ğ‘–).

2.4

Inverse of a shared secret
If participants would like to generate inverse shares of a shared secret ğ‘ âˆ’1 without a single entity
knowing the shared secret, the f ollowing process must be done. First notice that the interpolation of
the inverse shares is not the same as the inverse of the interpolation of the shares, that is,
)
ğ‘âˆ’1 = (ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ (ğ‘1 , â€¦ , ğ‘ğ‘¡ +1 )) âˆ’1 â‰  ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ (ğ‘1âˆ’1 , â€¦ , ğ‘âˆ’1
ğ‘¡+1 ,
which can be checked with a simple example. This implies that the shared secret ğ‘ must somehow
be calculated in f ull, without calculating it explicitly, bef ore calculating its inverse. We saw in the
previous sections that this can be done without knowing the result ğ‘ by blinding it with another
shared secret ğ‘. Note the blinding value must be a shared secret as well, otherwise the secret ğ‘
can be calculated.
In order to calculate the inverse of a shared secret ğ‘, the f ollowing steps must be taken.
1.
2.
3.

Calculate the product of shared secrets as in the previous section. That is, participant ğ‘–
executes ğ‘ƒğ‘…ğ‘‚ğ‘†ğ‘†(ğ‘–), the result of which is ğœ‡ = ğ‘ğ‘ mod ğ‘›.
Calculate the modular inverse of ğœ‡ which results in
ğœ‡âˆ’1 = (ğ‘ğ‘)âˆ’1 mod ğ‘› .
Each participant ğ‘– calculates their own inverse secret share by calculating
ğ‘âˆ’1
= ğœ‡âˆ’1 ğ‘ğ‘– .
ğ‘–

Page 6

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
This last equation is equivalent to ğ‘âˆ’1 ğ‘ âˆ’1 ğ‘ğ‘– mod ğ‘› if one substitutes in f or ğœ‡. One can then use
these inverse secret shares in a calculation with another shared secret, where the inverse of ğ‘ is
required. Interpolating over this will result in a calculation using ğ‘ âˆ’1 without ever explicitly knowing
ğ‘âˆ’1 .
We denote the steps in the inverse of shared secrets f or participant ğ‘– by ğ‘ğ‘–âˆ’1 = ğ¼ğ‘ğ‘‰ğ‘†ğ‘† (ğ‘–) .
This completes the section on the general JVRSS. In the next section, we give simple examples of
the methods described above.

Page 7

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

3

Secret sharing worked example
In this section we do worked examples to illustrate the ideas of the previous section. We begin by
looking a JVRSS scheme with 3 participants, 2 of which are required to recreate the secret , that is,
we take ğ‘ = 3 and ğ‘¡ = 1 in the previous section.

3.1

Joint Verifiable Random Secret Sharing
We describe a simple example of JVRSS. First, all the participants generate their share and then
verif y the shared secret. We begin with the generation of the shared secret shares.
Generation of secret shares
In order to generate shared secret shares the participants take the f ollowing steps.

Participant 1

Participant 2

Participant 3

Define private polynomial ğ‘“1 by
randomly generating coefficients:
ğ‘10 âˆˆğ‘… â„¤ ğ‘›
ğ‘11 âˆˆğ‘… â„¤ ğ‘›

Define private polynomial ğ‘“2 by
randomly generating coefficients:
ğ‘20 âˆˆğ‘… â„¤ ğ‘›
ğ‘21 âˆˆğ‘… â„¤ ğ‘›

Define private polynomial ğ‘“3 by
randomly generating coefficients:
ğ‘30 âˆˆğ‘… â„¤ ğ‘›
ğ‘31 âˆˆğ‘… â„¤ ğ‘›

Then define
ğ‘“1 ğ‘¥ = ğ‘10 + ğ‘11 ğ‘¥

Then define
ğ‘“2 (ğ‘¥) = ğ‘20 + ğ‘21 ğ‘¥

Then define
ğ‘“3 (ğ‘¥) = ğ‘30 + ğ‘31 ğ‘¥

Send ğ‘“1 (2) to participant 2 via a
secure communication channel
Send ğ‘“1 (3) to participant 3 via a
secure communication channel

Send ğ‘“2 (1) to participant 1 via a
secure communication channel
Send ğ‘“2 (3) to participant 3 via a
secure communication channel

Send ğ‘“3 (1) to participant 1 via a
secure communication channel
Send ğ‘“3 (2) to participant 2 via a
secure communication channel

Calculate own key share

Calculate own key share

Calculate own key share

ğ‘1 = ğ‘“1 1 + ğ‘“2 1 + ğ‘“3 1

ğ‘2 = ğ‘“1 2 + ğ‘“2 2 + ğ‘“3 2

ğ‘3 = ğ‘“1 3 + ğ‘“2 3 + ğ‘“3 3

These steps correspond exactly to step 1-3 in the general JVRSS scheme described in section 2.1.
The key shares f or each participant ğ‘– = 1, 2, 3 are
ğ‘ğ‘– = ğ‘“1 (ğ‘–) + ğ‘“2 (ğ‘–) + ğ‘“3 (ğ‘– ) ,
which are shares on the shared secret polynomial
ğ‘“(ğ‘) (ğ‘–) = (ğ‘10 + ğ‘20 + ğ‘30 ) + ğ‘– ( ğ‘11 + ğ‘21 + ğ‘31 ) ,
where the subscript (ğ‘) denotes that the polynomial corresponds to the shared secret ğ‘ which is
def ined to be
ğ‘ â‰” ( ğ‘10 + ğ‘20 + ğ‘30 ) .
In step 2 it is crucial that the point on each private polynomial f or participant ğ‘– is shared only with
participant ğ‘—. If all the polynomial points are shared then every private polynomial can be
calculated, and theref ore the shared secret. For example, if participant 1 shares the values ğ‘“1 (2)
and ğ‘“2 (3) with everyone, then all participants know two shares of an order-1 polynomial. Theref ore,
anyone can calculate the zeroth order of the polynomial using interpolation. This process could

Page 8

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
then be repeated f or all private polynomials, and theref ore everyone can calculate the shared
secret ğ‘ = âˆ‘ğ‘– ğ‘ğ‘–0 .
We can represent this process of generating the secret using a graph. In the graph below, we plot
each of the three private polynomials ğ‘“ğ‘– (ğ‘¥) and the shared secret polynomial ğ‘“(ğ‘) (ğ‘¥).
ğ‘“(ğ‘) (ğ‘¥)

ğ‘“3 (ğ‘¥)

ğ‘“2 (ğ‘¥)

ğ‘“1 (ğ‘¥)

Figure 1: A graphical representation of calculating a shared polynomial ğ‘“(ğ‘)(ğ‘¥) using JVRSS.1

The purple, teal, and orange line each represent a private polynomial corresponding each of the
participants. The blue polynomial is the summation of the three polynomials, resulting in the shared
polynomial, and the shared secret ğ‘ is where this shared polynomial crosses the ğ‘¦-axis. We
introduce the subscript in brackets notation to distinguish between shared polynomials f or different
secrets. In this f igure, the blue polynomial corresponds to the polynomial of the shared secret ğ‘.
Each participant ğ‘– calculates their point on the shared polynomial, by adding their share of each of
the private polynomials. Two of these shares can be used to f ind the shared secret polynomial.
The graph above represents polynomials over the real numbers. However, we are using
polynomials are over f inite f ields, that is, modulo some integer. Polynomials modulo an integer are
simply points on a graph rather than lines as shown above. We give the polynomials over the real
numbers as above f or illustrative purposes, since the principles are the same.
We now describe the steps taken to verif y the secret shares.
Verification of key shares
Bef ore any verif ication can take place, each participant must f irst share the f ollowing obfuscated
coef f icients of their private polynomials.

1

Page 9

This and all graphs to f ollow were created using the website graphsketch.com.

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

Participant 1

Participant 2

Participant 3

Broadcast obfuscated
coefficients polynomial ğ‘“1(ğ‘¥) to
all participants

Broadcast obfuscated
coefficients polynomial ğ‘“2(ğ‘¥) to
all participants

Broadcast obfuscated
coefficients polynomial ğ‘“3(ğ‘¥) to
all participants

(ğ‘11 â‹… ğº)
(ğ‘10 â‹… ğº)

(ğ‘21 â‹… ğº)
(ğ‘20 â‹… ğº)

(ğ‘31 â‹… ğº)
(ğ‘30 â‹… ğº)

This step corresponds to step 4 in the JVRSS described in section 2.1. Once this inf ormation is
shared, each participant can individually verif y the inf ormation given to them in step 2 of JVRSS
using these obf uscated coefficients.
Verification of polynomial points
Each participant verif ies the shares received f rom the other participants in the f ollowing way.

Participant 1

Participant 2

Participant 3

Verify that participant 2 sent ğ‘“2 1

Verify that participant 1 sent ğ‘“1 2

Verify that participant 1 sent ğ‘“1 3

ğ‘“2 1 â‹… ğº = (ğ‘21 â‹… ğº) + (ğ‘20 â‹… ğº)

ğ‘“1 2 â‹… ğº = 2(ğ‘11 â‹… ğº) + (ğ‘10 â‹… ğº)

ğ‘“1 3 â‹… ğº = 3(ğ‘11 â‹… ğº) + (ğ‘10 â‹… ğº)

Verify that participant 3 sent ğ‘“3 1

Verify that participant 3 sent ğ‘“3 2

Verify that participant 2 sent ğ‘“2 3

ğ‘“3 1 â‹… ğº = (ğ‘31 â‹… ğº) + (ğ‘30 â‹… ğº)

ğ‘“3 2 â‹… ğº = 2(ğ‘31 â‹… ğº) + (ğ‘30 â‹… ğº)

ğ‘“2 3 â‹… ğº = 3(ğ‘21 â‹… ğº) + (ğ‘20 â‹… ğº)

These steps correspond to step 5 in the general JVRSS scheme described in section 2.1.
Calculate shared public key
The f inal step in the generation of the shared secret is to calculate the corresponding public key.

Participant 1

Participant 2

Participant 3

C alculate public key ğ‘ â‹… ğº

C alculate public key ğ‘ â‹… ğº

C alculate public key ğ‘ â‹… ğº

ğ‘ â‹… ğº = (ğ‘10 â‹… ğº) + (ğ‘20 â‹… ğº ) + (ğ‘30 â‹… ğº)

ğ‘ â‹… ğº = (ğ‘10 â‹… ğº) + (ğ‘20 â‹… ğº ) + (ğ‘30 â‹… ğº)

ğ‘ â‹… ğº = (ğ‘10 â‹… ğº) + (ğ‘20 â‹… ğº ) + (ğ‘30 â‹… ğº)

Each participant ğ‘– can store this public key ğ‘ â‹… ğº with their secret share ğ‘ğ‘– .

3.2

Addition of shared secrets
We describe the steps f or calculating the addition of shared secrets.

Page 10

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

Participant 1

Participant 2

Participant 3

Generate the shared secret
share ğ‘1 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(1)

Generate the shared secret
share ğ‘2 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(2)

Generate the shared secret
share ğ‘3 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(3)

Generate blinding value share
ğ‘1 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(1)

Generate blinding value share
ğ‘2 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(2)

Generate blinding value share
ğ‘3 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(3)

Calculate intermediary share
ğœˆ1 = ğ‘1 + ğ‘1

Calculate intermediary share
ğœˆ2 = ğ‘2 + ğ‘2

Calculate intermediary share
ğœˆ3 = ğ‘3 + ğ‘3

Broadcast intermediary share ğœˆ1
to all participants

Broadcast intermediary share ğœˆ2
to all participants

Broadcast intermediary share ğœˆ3
to all participants

Calculate intermediary value
ğœˆ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğœˆ1, ğœˆ2, ğœˆ3

Calculate intermediary value
ğœˆ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğœˆ1, ğœˆ2, ğœˆ3

Calculate intermediary value
ğœˆ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğœˆ1, ğœˆ2, ğœˆ3

ğœˆ = ğ‘ +ğ‘

ğœˆ = ğ‘+ ğ‘

ğœˆ = ğ‘ +ğ‘

These steps correspond exactly to steps 1-5 in the protocol describing the addition of shared
secrets in section 2.2.
This can be shown graphically.

ğ‘“(ğ‘+ğ‘) (ğ‘¥)

ğ‘“(ğ‘) (ğ‘¥)

ğ‘“(ğ‘) (ğ‘¥)

Figure 2: A graphical representation of the addition of two shared secrets.

Page 11

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
In this graph there are two shared secrets corresponding to the orange and purple polynomials.
The addition of these polynomials results in the blue polynomial. Each participant adds their shares
f rom the orange and the purple polynomial, resulting in an additive share on the blue polynomial.
Interpolating over at least two shares on this polynomial results in the addition of the two secrets
(ğ‘ + ğ‘).

3.3

Product of shared secrets
We describe the steps f or calculating a product of shared secrets.

Participant 1

Participant 2

Participant 3

Generate the shared secret
share ğ‘1 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(1)

Generate the shared secret
share ğ‘2 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(2)

Generate the shared secret
share ğ‘3 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(3)

Generate blinding value share
ğ‘1 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(1)

Generate blinding value share
ğ‘2 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(2)

Generate blinding value share
ğ‘3 = ğ½ğ‘‰ğ‘…ğ‘†ğ‘†(3)

Calculate intermediary share
ğœ‡ 1 = ğ‘1ğ‘1

Calculate intermediary share
ğœ‡ 2 = ğ‘2ğ‘2

Calculate intermediary share
ğœ‡ 3 = ğ‘3ğ‘3

Broadcast intermediary share ğœ‡ 1
to all participants

Broadcast intermediary share ğœ‡ 2
to all participants

Broadcast intermediary share ğœ‡ 3
to all participants

Calculate intermediary value
ğœ‡ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğœ‡1, ğœ‡ 2, ğœ‡ 3

Calculate intermediary value
ğœ‡ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğœ‡1, ğœ‡ 2, ğœ‡ 3

Calculate intermediary value
ğœ‡ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğœ‡1, ğœ‡ 2, ğœ‡ 3

ğœ‡ = ğ‘ğ‘

ğœ‡ = ğ‘ğ‘

ğœ‡ = ğ‘ğ‘

These steps correspond to steps 1-5 in the protocol describing the product of shared secrets in
section 2.3.
We now show why the interpolation of the ğœ‡ ğ‘– = ğ‘ğ‘– ğ‘ğ‘– shares leads to ğœ‡ = ğ‘ğ‘. Figure 3 illustrates the
result of the multiplication of two polynomials of order-1.

Page 12

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

ğ‘“(ğ‘ğ‘) (ğ‘¥)

ğ‘“(ğ‘) (ğ‘¥)
ğ‘“(ğ‘) (ğ‘¥)

Figure 3: A graphical representation of a product of shared secrets.

The teal and purple lines in this graph are the shared polynomials corresponding to the secrets ğ‘
and ğ‘, respectively. The shared polynomial corresponding to the multiplication of these is given by
the order-2 polynomial in blue, and the value ğ‘ğ‘ is exactly where this multiplicative polynomial
crosses the ğ‘¦-axis. Since the polynomial corresponding to ğ‘ğ‘ is of order-2, at least 3 participants
are required to calculate the multiplicative polynomial secret ğœ‡, as described in section 2.3.

3.4

Inverse of a shared secret
We describe how to calculate the modular inverse of a shared secret.

Participant 1

Participant 2

Participant 3

Generate the shared secret
product ğ‘ƒğ‘…ğ‘‚ğ‘†ğ‘† 1 = ğœ‡ = ğ‘ğ‘

Generate the shared secret
product ğ‘ƒğ‘…ğ‘‚ğ‘†ğ‘† 2 = ğœ‡ = ğ‘ğ‘

Generate the shared secret
product ğ‘ƒğ‘…ğ‘‚ğ‘†ğ‘† 3 = ğœ‡ = ğ‘ğ‘

Calculate the modular inverse
ğœ‡ âˆ’1 = ğ‘ğ‘ âˆ’1mod ğ‘›

Calculate the modular inverse
ğœ‡ âˆ’1 = ğ‘ğ‘ âˆ’1 mod ğ‘›

Calculate the modular inverse
ğœ‡ âˆ’1 = ğ‘ğ‘ âˆ’1 mod ğ‘›

Calculate inverse secret share
âˆ’1
ğ‘âˆ’1
1 = ğœ‡ ğ‘1

Calculate inverse secret share
âˆ’1
ğ‘âˆ’1
2 = ğœ‡ ğ‘2

Calculate inverse secret share
âˆ’1
ğ‘âˆ’1
3 = ğœ‡ ğ‘3

These inverse key shares can be used as a usual shared secret and interpolation will result in the
calculation of ğ‘ âˆ’1.

Page 13

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
As mentioned, the blinding value is necessary to securely calculate the inverse of the ephemeral
key. . Because the shared ephemeral private key is the sum of the individuals shares, the inverse
of this cannot simply be calculated as the interpolation of the inverse shares, that is,
ğ‘âˆ’1 = (ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ (ğ‘1 , ğ‘2 , ğ‘3 )) âˆ’1 â‰  ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’(ğ‘1âˆ’1 , ğ‘2âˆ’1 , ğ‘3âˆ’1 ) .
The inverse is instead calculated using the product of the shared secret with a blinding value. The
interpolation over the product of the shares of the secrets calculates
ğœ‡ = ğ‘ğ‘ = (ğ‘10 + ğ‘20 + ğ‘30 )(ğ‘10 + ğ‘20 + ğ‘30 ) ,
and the inverse of this is the blinded inverse of the ephemeral key
ğœ‡ âˆ’1 = ğ‘ âˆ’1 ğ‘âˆ’1 = ( ğ‘10 + ğ‘20 + ğ‘30 ) âˆ’1 (ğ‘10 + ğ‘20 + ğ‘30 ) âˆ’1
As mentioned, the blinding value must also be kept secret, otherwise one can calculate the shared
secret.
To use this blinded inverse ğœ‡ âˆ’1 = (ğ‘ğ‘) âˆ’1 , the participants multiply the value by their blinding value
share to f ind an inverse shared secret share
ğ‘âˆ’1
= ğœ‡âˆ’1 ğ‘ğ‘– .
ğ‘–
Interpolating over these shares would result in
ğœ‡âˆ’1 ğ‘ = ğ‘ âˆ’1 ğ‘âˆ’1 ğ‘ = ğ‘âˆ’1 .
Since this is the secret that was being hidden in the f irst place, this calculation is not done, and is
mentioned f or illustrative purposes. However, the inverse shared secret shares ğ‘ğ‘–âˆ’1 can be used in
calculations with other shared secrets, such as the product of shared secrets again. For example, if
a shared secret share ğ‘ğ‘– is multiplied with the inverse shared secret shares and then interpolated,
one f inds the product of the shared secret ğ‘ multiplied with the inverse of a shared secret ğ‘âˆ’1
ğ‘âˆ’1 ğ‘ = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ (ğ‘1âˆ’1 ğ‘1 , â€¦ , ğ‘ğ‘™âˆ’1 ğ‘ğ‘™ ) ,
where ğ‘™ is at least the threshold of the product of the shared secret polynomials.
This completes the worked example of JVRSS. We now describe a use case f or this method, which
is threshold signatures.

Page 14

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

4

Threshold signatures
In this section we give an example of how to use the multiparty computations given in the previous
sections. This is to create a signature using a shared secret key between multiple parties, without
revealing the shared secret key.
A signature on a message is proof that the owner of a private key acknowledges the message and
that the message has not been tampered with since signing . Only the person with knowledge of the
private key can sign a message, and the signature depends on the message to ensure the
message isnâ€™t modif ied. In Elliptic Curve cryptography, the integrity of a signature depends on the
dif f icultly of solving the Elliptic Curve Discrete Logarithm Problem. That is, it is dif ficult to calculate
a private key, given the corresponding public key, and so it can be assumed that only the owner of
a private key can create a signature corresponding to that private key.
In Bitcoin, outputs of transactions can be spent by creating a signature using the private key
corresponding to the public key given in that output. These signatures are constructed and
validated using the Elliptic Curve Digital Signature Algorithm (ECDSA). This algorithm is easy to do
with a single signer, and transactions which are to be signed by multiple parties can simply repeat
this algorithm f or each individual signer.
In the f ollowing section we describe an alternative way to create transactions requiring multiple
signers. Signatures created using this scheme below are the same as signatures created by single
signers. That is, given a threshold signature, it looks like an ECDSA signature created with a single
private key. Theref ore, the locking and unlocking script in a transaction using this scheme is the
same as the usual P2PKH script, and this provides privacy to users of the scheme.
The concepts in this section are based on a paper by Gennaro et al [ 2]. We f inish this introduction
with the necessary mathematical background to understand the Threshold Signature algorithm. We
begin by describing ECDSA f or a given private key using the secp256k1 elliptic curve.
Elliptic Curve Digital Signature Algorithm (ECDSA)
In order to create a signature on a message, the message digest is f irst calculated
ğ‘’ = ğ‘†ğ»ğ´Ë—256 (ğ‘†ğ»ğ´Ë—256 (ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’ ) ) ,
by def inition. Then the signature is generated in the f ollowing way.
1.
2.
3.
4.
5.
6.

Choose a random integer ğ‘˜ âˆˆ {1, â€¦ , ğ‘› âˆ’ 1}, where ğ‘› is the order of the secp256k1 curve and
call ğ‘˜ the ephemeral key.
Calculate the ephemeral public key corresponding to this ephemeral private key
ğ‘˜ â‹… ğº = (ğ‘¥, ğ‘¦) .
Calculate ğ‘Ÿ = ğ‘¥ mod ğ‘›. If ğ‘Ÿ = 0, return to step 1.
Calculate the multiplicative inverse of the ephemeral key ğ‘˜ âˆ’1 in the f inite f ield corresponding
the secp256k1 curve.
Calculate ğ‘  = ğ‘˜ âˆ’1 (ğ‘’ + ğ‘ğ‘Ÿ) mod ğ‘›. If ğ‘  = 0, return to step 1.
The signature on the message is (ğ‘Ÿ, ğ‘ ) .

Note that each time a signature is generated, a dif f erent ephemeral key must be used. If this
doesnâ€™t happen, it is possible to calculate the private key.
Given a message, a public key (ğ‘ â‹… ğº), and corresponding signature (ğ‘Ÿ, ğ‘ ) , then one can verif y the
signature by completing the f ollowing steps.
1.
2.
3.

Page 15

Calculate the message digest ğ‘’ = ğ‘†ğ»ğ´Ë—256 (ğ‘†ğ»ğ´Ë—256 (ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’ ) ).
Calculate the multiplicative inverse ğ‘  âˆ’1 of ğ‘  modulo ğ‘›.
Calculate ğ‘—1 = ğ‘’ğ‘  âˆ’1 mod ğ‘› and ğ‘—2 = ğ‘Ÿğ‘  âˆ’1 mod ğ‘›.

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
4.
5.
6.

Calculate the point ğ‘„ = ğ‘—1 â‹… ğº + ğ‘—2 (ğ‘ â‹… ğº ) .
If ğ‘„ = ğ’ª, the point at inf inity, the signature is invalid.
If ğ‘„ â‰  ğ’ª, then let ğ‘„ â‰” (ğ‘¥, ğ‘¦) , and calculate ğ‘¢ = ğ‘¥ mod ğ‘›. If ğ‘¢ = ğ‘Ÿ, the signature is valid.

This completes the description of ECDSA signature calculation and verif ication. We now describe
how to generate a shared private key ğ‘, that is later used to create an ECDSA signature.

4.1

Shared private key generation and verification
To calculate a shared private key ğ‘ between ğ‘ participants, ğ‘€ = 2ğ‘¡ + 1 of which are required to
create a signature, they execute JVRSS described in section 2.1. The result is that every
participant ğ‘– = 1, â€¦ , ğ‘ has a private key share ğ‘ğ‘– with threshold ğ‘¡ + 1. The participants calculate the
shared public key using the method described at the end of section 2.1. This results in a shared
public key (ğ‘ â‹… ğº), and each participant saf ely stores this along with their private key share ğ‘ğ‘– . This
shared private key shall be used to sign messages using the ECDSA scheme.
Note that signatures with the shared secret require 2ğ‘¡ + 1 participants. This is because the
ephemeral key must be a shared secret as well as the priv ate key. If the ephemeral key were not
secret, then anyone with knowledge of the signature, message, and ephemeral private key would
be able to calculate the shared private key ğ‘. Theref ore, a signature is calculated with the
multiplication of two shared secret polynomials of order ğ‘¡, and so the multiplicative shared
polynomial will have order 2ğ‘¡, with 2ğ‘¡ + 1 shares required to recreate it. Finally, this implies that the
signing threshold of a scheme with ğ‘ participants is restricted by the inequality 2ğ‘¡ + 1 â‰¤ ğ‘ . Clearly,
if the threshold is larger than the number of participants, then the group will not be able to sign any
messages.
We describe the process f or generating shared ephemeral keys that will be used in the signature.

4.2

Ephemeral key shares generation
The next step is to generate ephemeral key shares and the corresponding ğ‘Ÿ, as required in a
signature. The general process f or this is as f ollows.
1.
2.

Generate the inverse share of a shared secret ğ‘˜ğ‘–âˆ’1 = ğ¼ğ‘ğ‘‰ğ‘†ğ‘†(ğ‘–), where (ğ‘¡ + 1) shares are
required to recreate it.
Each participant calculates
ğ‘

(ğ‘¥, ğ‘¦) = âˆ‘ (ğ‘˜ğ‘–0 â‹… ğº) ,
ğ‘– =1

3.

using the obf uscated coefficients shared in the verif ication of ğ‘˜ğ‘– , then they calculate
ğ‘Ÿ = ğ‘¥ mod ğ‘› .
âˆ’1
Each participant ğ‘– stores (ğ‘Ÿ, ğ‘˜ğ‘– ).

Note that ephemeral keys should never be used more than once to calculate a signature. If
ephemeral keys are used f or dif f erent messages, the private key is calculable.

4.3

Signature generation
We describe the process f or generating a signature with the shared private key ğ‘. Assume that at
least ğ‘€ = 2ğ‘¡ + 1 participants would like to create a signature on a message, and one of the
participants chooses to coordinate this. The f ollowing steps are taken.
1.

Page 16

The coordinator requests a signature on the message f rom at least ğ‘€ = 2ğ‘¡ + 1 participants.

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures
2.
3.
4.

5.
6.

7.

Each participant ğ‘– recovers the next ephemeral key (ğ‘Ÿ, ğ‘˜ğ‘–âˆ’1 ). All users must use a share
corresponding to the same ephemeral key.
Each participant calculates the message digest ğ‘’ = ğ‘†ğ»ğ´Ë—256 (ğ‘†ğ»ğ´Ë—256 (ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’ ) ).
Each participant ğ‘– calculates their own signature share ğ‘ ğ‘–
ğ‘ ğ‘– = ğ‘˜ğ‘–âˆ’1 (ğ‘’ + ğ‘ğ‘– ğ‘Ÿ) mod ğ‘› ,
where ğ‘ğ‘– is their private key share.
Each participant sends their signature share (ğ‘Ÿ, ğ‘ ğ‘– ) to the coordinator.
When the coordinator has received ğ‘€ signature shares, they calculate
ğ‘  = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ (ğ‘ 1 , â€¦ , ğ‘ 2ğ‘¡ +1 ) ,
and output the signature as (ğ‘Ÿ, ğ‘ ).
The coordinator verif ies the signature using the ECDSA described in section 4.1. If this f ails, at
least one of the shares must be incorrect, and the signature generation algorithm should be run
again.

It is possible to f ind a dishonest actor if the signature f ails the verif ication, with the inf ormation
obtained in JVRSS. Each coordinator wanting to f ind a malicious actor would need to store some
additional inf ormation f rom the JVRSS protocol. Recall that the public keys correspond ing to each
participantâ€™s point on each participantâ€™s private polynomial is shared
ğ‘“ğ‘– (ğ‘—) â‹… ğº,

âˆ€ğ‘–, ğ‘— = 1, â€¦ , ğ‘.

All participants can calculate the public key corresponding to each participant ğ‘—â€™s private key ğ‘ğ‘—
share by simply adding the corresponding values
ğ‘›

ğ‘ğ‘— â‹… ğº = âˆ‘ ğ‘“ğ‘– (ğ‘—) â‹… ğº .
ğ‘–=1

Given participant ğ‘—â€™s signature share (ğ‘Ÿ, ğ‘ ğ‘— ), this public key ğ‘ğ‘— â‹… ğº, and the message, one can verif y
is this is the correct signature share. If the verif ication does not hold, the coordinator knows that
this is an incorrect share.
We now do a worked example of a group of size 3, all of which are required to calculate a
signature. This is called a 3-of -3 signature scheme.

Page 17

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

5

Threshold signatures worked example
We give a simple example of a threshold signature scheme, a 3-of -3 scheme, meaning that all
three participants in a scheme are required to generate a signature.

5.1

Shared private key generation and verification
All the participants generate and verif y their share of the signing key and calculate the shared
public key. This is done using JVRSS and method 2 of calculating the shared public key as
described in section 2.1. The result is that each participant has a share ğ‘ğ‘– of a shared private key
ğ‘, with corresponding shared public key (ğ‘ â‹… ğº).

5.2

Ephemeral key shares generation
Multiple of these ephemeral keys and the corresponding ğ‘Ÿ value are pre-calculated and stored at
the initial set-up, so that they do not need to be calculated f or each signing.
We describe the process f or generating these ephemeral keys. We f ocus on the generation of one
ephemeral key and its corresponding ğ‘Ÿ, and this process is repeated f or as many precalculated
ephemeral keys as required.

Participant 1

Participant 2

Participant 3

Generate inverse ephemeral key
share ğ‘˜1âˆ’1 = ğ¼ğ‘ğ‘‰ğ‘†ğ‘†(1)

Generate inverse ephemeral key
share ğ‘˜2âˆ’1 = ğ¼ğ‘ğ‘‰ğ‘†ğ‘†(2)

Generate inverse ephemeral key
share ğ‘˜3âˆ’1 = ğ¼ğ‘ğ‘‰ğ‘†ğ‘†(3)

Calculate ğ‘¥,ğ‘¦ = ğ‘˜ â‹… ğº from the
verification data sent by each
participant, then ğ‘Ÿ = ğ‘¥ mod ğ‘›

Calculate ğ‘¥,ğ‘¦ = ğ‘˜ â‹… ğº from the
verification data sent by each
participant, then ğ‘Ÿ = ğ‘¥ mod ğ‘›

Calculate ğ‘¥,ğ‘¦ = ğ‘˜ â‹… ğº from the
verification data sent by each
participant, then ğ‘Ÿ = ğ‘¥ mod ğ‘›

Store (ğ‘Ÿ, ğ‘˜âˆ’1
1 )

Store (ğ‘Ÿ, ğ‘˜âˆ’1
2 )

Store (ğ‘Ÿ, ğ‘˜âˆ’1
3 )

In the second step, ğ‘˜ â‹… ğº is calculated using ğ‘˜ğ‘–0 â‹… ğº that each participant shares in the JVRSS step.
Then the ğ‘¥-coordinate of the result modulo ğ‘› is the def inition of ğ‘Ÿ.
This completes the description of the ephemeral key shares. We now describe how to use these
and the shared private key to calculate a shared signature.

5.3

Signature generation
To calculate a shared signature in a 3-of -3 scheme, the f ollowing steps are taken.

Page 18

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

2
Participant
Coordinator1
Send a message to all participants
requesting a signature for a
message

Participant 1

Participant 2

Participant 3

Recover next unused (ğ‘Ÿ, ğ‘˜âˆ’1
1 )

Recover next unused (ğ‘Ÿ, ğ‘˜âˆ’1
2 )

Recover next unused (ğ‘Ÿ, ğ‘˜âˆ’1
3 )

Hash the message to be signed
ğ‘’ = â„ğ‘ğ‘ â„(ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’)

Hash the message to be signed
ğ‘’ = â„ğ‘ğ‘ â„(ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’)

Hash the message to be signed
ğ‘’ = â„ğ‘ğ‘ â„(ğ‘šğ‘’ğ‘ ğ‘ ğ‘ğ‘”ğ‘’)

Generate share of the signature
ğ‘ 1 = ğ‘˜1âˆ’1 ğ‘’ + ğ‘1 ğ‘Ÿ mod ğ‘›

Generate share of the signature
ğ‘ 2 = ğ‘˜âˆ’1
2 ğ‘’ + ğ‘2 ğ‘Ÿ mod ğ‘›

Generate share of the signature
ğ‘ 3 = ğ‘˜âˆ’1
3 ğ‘’ + ğ‘3 ğ‘Ÿ mod ğ‘›

Send (ğ‘Ÿ,ğ‘ 1 ) to the coordinator

Send (ğ‘Ÿ,ğ‘ 2 ) to the coordinator

Send (ğ‘Ÿ,ğ‘ 3 ) to the coordinator

Coordinator
Calculate signature
ğ‘  = ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘ğ‘œğ‘™ğ‘ğ‘¡ğ‘’ ğ‘ 1 ,ğ‘ 2 , ğ‘ 3
The signature is (ğ‘Ÿ,ğ‘ )

Verify signature using standard
ECDSA verification

Lagrange interpolation over the signature shares ef f ectively calculates the polynomial
ğ‘“(ğ‘ ) (ğ‘¥) = (ğ‘˜ âˆ’1 ğ›¼ âˆ’1 ) Ã— ğ‘“(ğ›¼) (ğ‘¥)(ğ‘’ + ğ‘“(ğ‘) (ğ‘¥) ğ‘Ÿ) ,
where ğ‘˜ is the ephemeral key, ğ›¼ is the blinding secret, ğ‘“(ğ›¼) (ğ‘¥) is the order-1 polynomial
corresponding to the blinding secret, and ğ‘“(ğ‘) (ğ‘¥) is the order-1 polynomial corresponding to the
shared private key. The polynomial corresponding to the signature is order-2 and so 3 participants
are required to create it. The value of this at ğ‘¥ = 0 is
ğ‘“(ğ‘ ) (0) = ğ‘˜ âˆ’1 (ğ‘’ + ğ‘ğ‘Ÿ) ,
which is the signature on the message by the private key ğ‘ as required. Finally, the signature is
(ğ‘Ÿ, ğ‘ ).This completes the worked example of a 3-of -3 threshold signature scheme, and our
description of secret sharing and threshold signatures.

Page 19

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

Shared Secrets and Threshold Signatures

6

Page 20

References
Reference

Author, date, name & location

[1]

Pedersen, T. P. "A threshold cryptosystem without a trusted
party." Workshop on the Theory and Application of Cryptographic
Techniques. Springer, Berlin, Heidelberg, 1991.

[2]

Gennaro, R, et al. "Robust threshold DSS signatures." International
Conference on the Theory and Applications of Cryptographic Techniques.
Springer, Berlin, Heidelberg, 1996.

COMMERCIAL IN CONFIDENCE

Â© nChain Limited.
Michaella Pettit

