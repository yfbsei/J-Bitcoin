diff --git a/src-md/bip/BIP173-BIP350.md b/src-md/bip/BIP173-BIP350.md
new file mode 100644
index 0000000000000000000000000000000000000000..6795feb62e41083270f1fb444799ff0845842771
--- /dev/null
+++ b/src-md/bip/BIP173-BIP350.md
@@ -0,0 +1,52 @@
+# Bech32 / Bech32m Address Encoding — `BIP173-BIP350.js`
+
+This module implements the complete [BIP173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) and [BIP350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki) specifications used to encode SegWit addresses. It provides strict human-readable part (HRP) validation, checksum generation, and witness program conversion utilities.
+
+Key features:
+
+- ✔️ Encode witness programs into Bech32 or Bech32m strings
+- ✔️ Decode and validate addresses with checksum and case checks
+- 🔄 Bit-width conversion helpers for 8‑bit to 5‑bit groups
+- 🔒 Custom `Bech32Error` for precise error reporting
+
+---
+
+## 🧪 Examples
+
+### Encode a P2WPKH Address
+```js
+import { BECH32 } from './BIP173-BIP350.js';
+
+const program = new Uint8Array(20).fill(0); // witness program
+const address = BECH32.encode('bc', program, 'bech32');
+console.log(address);
+```
+
+### Decode a Bech32m Address
+```js
+const info = BECH32.decode('bc1p...');
+console.log(info.hrp);
+console.log(info.encoding); // 'bech32m'
+```
+
+---
+
+## 🧠 API Reference
+
+### `BECH32.encode(prefix, data, encoding = 'bech32')`
+Returns a valid Bech32/Bech32m string.
+
+### `BECH32.decode(address, expectedHrp?)`
+Parses and validates an address and returns `{ hrp, data, encoding }`.
+
+### `BECH32.verifyChecksum(hrp, data, encoding)`
+Validates the checksum for a given HRP and data array.
+
+### `BECH32.createChecksum(hrp, data, encoding)`
+Generates the checksum bytes for an address.
+
+### `EnhancedBitConverter.convertBits(data, fromBits, toBits, pad = true)`
+Converts between bit groups (e.g. 8‑bit to 5‑bit) with optional padding.
+
+**Exports:** `Bech32Error`, `Bech32Validator`, `EnhancedBitConverter`, `BECH32_CONSTANTS`, `OFFICIAL_TEST_VECTORS`, and `BECH32`.
+
diff --git a/src-md/bip/bip32/derive.md b/src-md/bip/bip32/derive.md
new file mode 100644
index 0000000000000000000000000000000000000000..4c0ec1ff219c988d0114645d03ebc210f70ab67a
--- /dev/null
+++ b/src-md/bip/bip32/derive.md
@@ -0,0 +1,109 @@
+# BIP32 Key Derivation — `derive()`
+
+This module implements **BIP32 hierarchical deterministic key derivation**, allowing the creation of a full tree of private and public cryptographic keys from a single master key.
+
+It supports both **hardened** and **non-hardened** derivations using elliptic curve cryptography (secp256k1), making it compatible with BIP44, BIP49, and BIP84 paths. The derivation process is secure, deterministic, and compliant with industry standards.
+
+> 🔒 Hardened derivation requires access to private keys and is recommended for sensitive paths.  
+> 🔑 Non-hardened derivation allows watch-only wallets using public keys.
+
+---
+
+## 🧪 Examples
+
+### Derive BIP44 Account Keys
+```js
+import { fromSeed } from './fromSeed.js';
+import derive from './derive.js';
+
+const seed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
+const [masterKeys, masterFormat] = fromSeed(seed, "main");
+
+const [accountKeys, accountFormat] = derive("m/44'/0'/0'", masterKeys.HDpri, masterFormat);
+const [changeKeys, changeFormat] = derive("m/0", accountKeys.HDpri, accountFormat);
+const [addressKeys, addressFormat] = derive("m/0", changeKeys.HDpri, changeFormat);
+
+console.log("Final address key:", addressKeys.HDpub);
+```
+
+### Derive Public Key Only (Non-Hardened)
+```js
+const [publicDerived, _] = derive("m/0/1/2", masterKeys.HDpub, masterFormat);
+console.log("Public-derived key:", publicDerived.HDpub);
+console.log("Private key:", publicDerived.HDpri); // null
+```
+
+### Handle Hardened Path Errors
+```js
+try {
+  // Will fail due to hardened path with public key
+  derive("m/0'", masterKeys.HDpub, masterFormat);
+} catch (error) {
+  console.log(error.message); // "Public Key can't derive from hardend path"
+}
+```
+
+### Derive BIP49 P2SH-wrapped SegWit Path
+```js
+const [segwitKeys, segwitFormat] = derive("m/49'/0'/0'/0/0", masterKeys.HDpri, masterFormat);
+console.log("Depth:", segwitFormat.depth);
+console.log("Child index:", segwitFormat.childIndex);
+console.log("Parent fingerprint:", segwitFormat.parentFingerPrint.toString('hex'));
+```
+
+### Derive First 10 Addresses (Iteratively)
+```js
+let currentKeys = masterKeys;
+let currentFormat = masterFormat;
+const pathSteps = ["44'", "0'", "0'", "0"];
+
+for (const step of pathSteps) {
+  [currentKeys, currentFormat] = derive(`m/${step}`, currentKeys.HDpri, currentFormat);
+}
+
+for (let i = 0; i < 10; i++) {
+  const [addrKeys, _] = derive(`m/${i}`, currentKeys.HDpri, currentFormat);
+  console.log(`Address ${i}:`, addrKeys.HDpub);
+}
+```
+
+---
+
+## 🧠 API Reference
+
+### `derive(path, key, serialization_format)`
+Derives a child key from a BIP32 path.
+
+#### Parameters:
+- `path` `{string}` – Derivation path (e.g. `"m/44'/0'/0'/0/0"`)
+- `key` `{string}` – Extended key (`xprv`/`xpub`, `tprv`/`tpub`)
+- `serialization_format` `{Object}` – Metadata from `fromSeed`
+
+#### Returns:
+- `[DerivedKeyPair, Object]`  
+  - `HDpri`: Extended private key or `null`  
+  - `HDpub`: Extended public key  
+  - Updated serialization format for chaining
+
+#### Throws:
+- `Error`: If hardened path is used with public key  
+- `Error`: If path or key format is invalid  
+- `Error`: If derived key is invalid
+
+#### Usage Notes:
+- Supports both hardened and non-hardened derivation
+- Public key derivation allowed only for non-hardened paths
+- Output keys are BIP32 compliant
+- Works with Bitcoin mainnet and testnet keys
+
+---
+
+## 📖 Specification Compliance
+
+- [BIP32: Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
+- [BIP44: Multi-Account Hierarchy](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
+- [BIP49 / BIP84: SegWit Compatible Paths](https://github.com/bitcoin/bips)
+
+```diff
++ Fully compatible with all BIP32-compliant wallets and libraries.
+```
diff --git a/src-md/bip/bip32/master-key.md b/src-md/bip/bip32/master-key.md
new file mode 100644
index 0000000000000000000000000000000000000000..e229ba9db6acc0e2c5ca0c53dec56506bee41913
--- /dev/null
+++ b/src-md/bip/bip32/master-key.md
@@ -0,0 +1,48 @@
+# BIP32 Master Key Generation — `master-key.js`
+
+Generates the root extended keys for a hierarchical deterministic wallet. The implementation follows [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) with additional validation to reject weak keys and securely wipe intermediate buffers.
+
+Key features:
+
+- ✅ Validates seed size and network parameters
+- 🔒 Rejects invalid master keys (IL ≥ n or zero)
+- ♻️ Optional retry logic via `generateMasterKeySecure`
+- 🧪 Built‑in test vector validation
+
+---
+
+## 🧪 Examples
+
+### Generate Master Keys from Seed
+```js
+import { generateMasterKey } from './master-key.js';
+
+const seed = '000102030405060708090a0b0c0d0e0f';
+const [keys, fmt] = generateMasterKey(seed, 'main');
+console.log(keys.extendedPrivateKey);
+```
+
+### Secure Generation with Automatic Retry
+```js
+import { generateMasterKeySecure } from './master-key.js';
+const [keys] = generateMasterKeySecure(seed, 'test');
+```
+
+---
+
+## 🧠 API Reference
+
+### `generateMasterKey(seedHex, network = 'main')`
+Returns `[HDKeys, format]` where `HDKeys` contains `extendedPrivateKey` and `extendedPublicKey`.
+
+### `generateMasterKeySecure(seedHex, network = 'main')`
+Wraps `generateMasterKey` with additional validation and retry logic.
+
+### `validateMasterKeyGeneration()`
+Runs an internal test using the official BIP32 vector.
+
+### `BIP32SecurityUtils`
+Helper class providing seed and extended key validators.
+
+**Exports:** `BIP32SecurityUtils`, `ENHANCED_BIP32_CONSTANTS`, `generateMasterKey`, `generateMasterKeySecure`, `validateMasterKeyGeneration`.
+
diff --git a/src-md/bip/bip39/mnemonic.md b/src-md/bip/bip39/mnemonic.md
new file mode 100644
index 0000000000000000000000000000000000000000..33545276c5cb8c07f0d0e0f219ca20d6b23b6987
--- /dev/null
+++ b/src-md/bip/bip39/mnemonic.md
@@ -0,0 +1,103 @@
+# BIP39 Mnemonic Generator & Seed Derivation — `BIP39`
+
+This module implements the [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) standard for generating **mnemonic phrases** and converting them into cryptographic **seeds**. It supports secure 12-word phrase generation, checksum validation, and PBKDF2-HMAC-SHA512-based seed derivation with optional passphrases.
+
+> 🔐 Designed for deterministic Bitcoin wallets  
+> ✅ Compatible with BIP32 / BIP44 key derivation  
+> 💬 English wordlist included
+
+---
+
+## 🧪 Examples
+
+### Generate Random Mnemonic and Seed
+```js
+const { mnemonic, seed } = BIP39.random('my-secure-passphrase');
+console.log(mnemonic); // e.g. "abandon ability able about ..."
+console.log(seed);     // Hex string (64 bytes / 512 bits)
+```
+
+### Validate a Mnemonic Phrase
+```js
+const mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
+const isValid = BIP39.checkSum(mnemonic); // true
+```
+
+### Convert Mnemonic to Seed
+```js
+const seed = BIP39.seed(mnemonic, "passphrase");
+console.log(seed); // Hex string
+```
+
+### Strict Seed Conversion With Validation
+```js
+try {
+  const secureSeed = BIP39.mnemonic2seed(mnemonic, "passphrase");
+} catch (error) {
+  console.error(error.message); // "Invalid checksum: Mnemonic phrase validation failed"
+}
+```
+
+---
+
+## 🧠 API Reference
+
+### `BIP39.random(passphrase = '')`
+Generates a valid 12-word mnemonic and its derived seed.
+
+- **Returns:** `{ mnemonic: string, seed: string }`
+- **Throws:** Error if checksum fails (extremely rare)
+
+---
+
+### `BIP39.mnemonic()`
+Generates a 12-word mnemonic phrase with a valid checksum.
+
+- **Returns:** `{string}` 12-word phrase
+
+---
+
+### `BIP39.seed(mnemonic, passphrase)`
+Converts a mnemonic to a cryptographic seed (no checksum check).
+
+- **Returns:** `{string}` Hex-encoded 512-bit seed  
+- **Params:**  
+  - `mnemonic` `{string}`  
+  - `passphrase` `{string}` (optional)
+
+---
+
+### `BIP39.mnemonic2seed(mnemonic, passphrase)`
+Strict version of `.seed()` — validates checksum before derivation.
+
+- **Returns:** `{string}` Hex-encoded 512-bit seed  
+- **Throws:** Error if checksum is invalid
+
+---
+
+### `BIP39.checkSum(mnemonic)`
+Validates the checksum of a mnemonic phrase.
+
+- **Returns:** `{boolean}` true if valid, false otherwise
+
+---
+
+## 🔐 Security Notes
+
+- Entropy is 128-bit (16 bytes) — matches standard wallets
+- Derived seed is 64 bytes, suitable for BIP32 master key generation
+- Mnemonics should be stored securely and backed up
+- Passphrases are optional but recommended for added security
+- Never transmit mnemonics or seeds over insecure channels
+
+---
+
+## 📖 Standards Compliance
+
+- ✅ BIP39: Mnemonic → Seed  
+- ✅ Interoperable with Ledger, Trezor, Electrum, MetaMask, etc.  
+- ✅ Works with BIP32/BIP44 for HD wallet generation
+
+```diff
++ Use with `fromSeed()` and `derive()` to build full HD key hierarchies.
+```
diff --git a/src-md/core/constants.md b/src-md/core/constants.md
new file mode 100644
index 0000000000000000000000000000000000000000..78d5e14daf14008c0f26780a240c7066cad287e4
--- /dev/null
+++ b/src-md/core/constants.md
@@ -0,0 +1,165 @@
+# Bitcoin Constants & Configuration - J-Bitcoin
+
+This module provides centralized constants and utility functions for handling Bitcoin-specific configuration in the J-Bitcoin library.
+
+## Overview
+
+It supports:
+
+- BIP44/BIP49/BIP84/BIP86 derivation path standards
+- Mainnet and Testnet configurations
+- Address format identifiers (Legacy, SegWit, Taproot)
+- Derivation path generation and parsing
+- Validation of Bitcoin derivation paths
+
+## Exports
+
+### `BIP44_CONSTANTS`
+
+Constants related to BIP44 key derivation.
+
+```js
+BIP44_CONSTANTS = {
+  PURPOSE: 44,
+  COIN_TYPES: {
+    BITCOIN_MAINNET: 0,
+    BITCOIN_TESTNET: 1
+  },
+  ACCOUNT: 0,
+  CHANGE: {
+    EXTERNAL: 0,
+    INTERNAL: 1
+  }
+}
+```
+
+### `DERIVATION_PATHS`
+
+Predefined derivation paths.
+
+```js
+DERIVATION_PATHS = {
+  BITCOIN_LEGACY: "m/44'/0'/0'",
+  BITCOIN_TESTNET: "m/44'/1'/0'",
+  BITCOIN_RECEIVING: "m/44'/0'/0'/0",
+  BITCOIN_CHANGE: "m/44'/0'/0'/1",
+  BITCOIN_FIRST_ADDRESS: "m/44'/0'/0'/0/0",
+  BITCOIN_FIRST_CHANGE: "m/44'/0'/0'/1/0",
+  TESTNET_RECEIVING: "m/44'/1'/0'/0",
+  TESTNET_CHANGE: "m/44'/1'/0'/1"
+}
+```
+
+### `NETWORKS`
+
+Network configuration for Bitcoin mainnet and testnet.
+
+```js
+NETWORKS = {
+  MAINNET: {
+    name: 'Bitcoin',
+    symbol: 'BTC',
+    coinType: 0,
+    addressPrefix: 'bc',
+    legacyPrefix: '1',
+    p2shPrefix: '3',
+    network: 'main'
+  },
+  TESTNET: {
+    name: 'Bitcoin Testnet',
+    symbol: 'BTC',
+    coinType: 1,
+    addressPrefix: 'tb',
+    legacyPrefix: 'm',
+    legacyPrefixAlt: 'n',
+    p2shPrefix: '2',
+    network: 'test'
+  }
+}
+```
+
+### `ADDRESS_FORMATS`
+
+Supported Bitcoin address formats.
+
+```js
+ADDRESS_FORMATS = {
+  LEGACY: 'legacy',
+  SEGWIT: 'segwit',
+  P2SH: 'p2sh'
+}
+```
+
+### `BIP_PURPOSES`
+
+BIP standards for derivation.
+
+```js
+BIP_PURPOSES = {
+  LEGACY: 44,
+  NESTED_SEGWIT: 49,
+  NATIVE_SEGWIT: 84,
+  TAPROOT: 86
+}
+```
+
+## Functions
+
+### `generateDerivationPath(options)`
+
+Generates a full derivation path based on options.
+
+```js
+generateDerivationPath({
+  purpose = 44,
+  coinType = 0,
+  account = 0,
+  change = 0,
+  addressIndex = 0
+})
+```
+
+Example:
+
+```js
+generateDerivationPath({ addressIndex: 5 });
+// "m/44'/0'/0'/0/5"
+```
+
+### `parseDerivationPath(path)`
+
+Parses a derivation path into components.
+
+```js
+parseDerivationPath("m/44'/0'/0'/0/5")
+```
+
+Returns:
+
+```js
+{
+  purpose: 44,
+  coinType: 0,
+  account: 0,
+  change: 0,
+  addressIndex: 5
+}
+```
+
+### `isValidBitcoinPath(path)`
+
+Checks if a derivation path is valid for Bitcoin (coinType 0 or 1).
+
+### `getNetworkByCoinType(coinType)`
+
+Returns network configuration for Bitcoin based on BIP44 coin type.
+
+```js
+getNetworkByCoinType(0).name // "Bitcoin"
+```
+
+---
+
+## License
+
+MIT
\ No newline at end of file
diff --git a/src-md/core/crypto/hash/ripemd160.md b/src-md/core/crypto/hash/ripemd160.md
new file mode 100644
index 0000000000000000000000000000000000000000..a6e51970232c67149765fa5f4721921894664869
--- /dev/null
+++ b/src-md/core/crypto/hash/ripemd160.md
@@ -0,0 +1,32 @@
+# RIPEMD160 Hash — `ripemd160.js`
+
+Provides a pure JavaScript implementation of the RIPEMD160 hash algorithm. The function is used in Bitcoin address creation as part of the HASH160 operation (`sha256` followed by `ripemd160`).
+
+Key features:
+
+- 🔐 No external dependencies
+- 🏎️ Reasonable performance for browser or Node use
+- 📦 Returns raw `Buffer` output
+
+---
+
+## 🧪 Example
+
+```js
+import rmd160 from './ripemd160.js';
+const digest = rmd160(Buffer.from('hello'));
+console.log(digest.toString('hex'));
+```
+
+---
+
+## 🧠 API Reference
+
+### `rmd160(data)`
+Computes RIPEMD160 over `Buffer`, `Uint8Array`, or string input.
+
+- **Parameters:** `data` `{Buffer|Uint8Array|string}`
+- **Returns:** `{Buffer}` 20‑byte hash
+
+**Exports:** default function `rmd160`.
+
diff --git a/src-md/core/crypto/signatures/ecdsa.md b/src-md/core/crypto/signatures/ecdsa.md
new file mode 100644
index 0000000000000000000000000000000000000000..c4632f782964fd43dbb4629b23bb2dd16c9289cd
--- /dev/null
+++ b/src-md/core/crypto/signatures/ecdsa.md
@@ -0,0 +1,82 @@
+# ECDSA Signing & Verification — `ECDSA`
+
+This module provides full support for [ECDSA](https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm) (Elliptic Curve Digital Signature Algorithm) operations using the **secp256k1** curve (used by Bitcoin). It includes:
+
+- 🔐 **Secure signing** with deterministic k-values (RFC 6979)
+- ✅ **Signature verification** with public key
+- 🔄 **Public key recovery** using signature + message
+
+---
+
+## 🧪 Examples
+
+### Sign a Message
+```js
+const privateKey = "L1vHfV6GUbMJSvFaqjnButzwq5x4ThdFaotpUgsfScwMNKjdGVuS";
+const [signature, recoveryId] = ECDSA.sign(privateKey, "Hello Bitcoin!");
+```
+
+### Verify a Signature
+```js
+const isValid = ECDSA.verify(signature, "Hello Bitcoin!", publicKey);
+console.log(isValid); // true
+```
+
+### Recover Public Key from Signature
+```js
+const pubKey = ECDSA.retrieve_public_key("Hello Bitcoin!", signature, recoveryId);
+```
+
+---
+
+## 🧠 API Reference
+
+### `ECDSA.sign(private_key, message)`
+Signs a UTF-8 string message using a WIF-encoded private key.
+
+- **Parameters:**
+  - `private_key` `{string}` – WIF format private key (e.g. starts with "L", "K", or "5")
+  - `message` `{string}` – Message to sign
+- **Returns:** `[signature: Uint8Array, recoveryId: number]`
+- **Throws:** Error if signing fails
+
+---
+
+### `ECDSA.verify(signature, message, public_key)`
+Verifies a signature against a message and public key.
+
+- **Parameters:**
+  - `signature` `{Uint8Array}` – DER-encoded signature
+  - `message` `{string}` – Message that was signed
+  - `public_key` `{Uint8Array}` – Compressed or uncompressed public key
+- **Returns:** `{boolean}` true if valid, false otherwise
+
+---
+
+### `ECDSA.retrieve_public_key(message, signature, recovery)`
+Recovers the public key used to create a signature, given the original message and the recovery ID.
+
+- **Parameters:**
+  - `message` `{string}` – Message that was signed
+  - `signature` `{Uint8Array}` – Signature from `.sign()`
+  - `recovery` `{number}` – Recovery ID from `.sign()` (0–3)
+- **Returns:** `{Uint8Array}` Compressed public key (33 bytes)
+
+---
+
+## 🔐 Security Notes
+
+- Uses `secp256k1` curve as per Bitcoin standard
+- Deterministic signatures prevent nonce-based vulnerabilities
+- Private keys must be securely stored and never exposed
+
+---
+
+## 📌 Notes
+
+- Public key recovery is useful in protocols like Ethereum or verifying messages without transmitting public keys
+- This module can integrate with your BIP32/BIP39 flow to provide a complete signing stack
+
+```diff
++ Use this module to securely sign and verify messages on Bitcoin-compatible systems.
+```
diff --git a/src-md/core/crypto/signatures/schnorr-BIP340.md b/src-md/core/crypto/signatures/schnorr-BIP340.md
new file mode 100644
index 0000000000000000000000000000000000000000..0f3effe45c59cc859a677d46ff635148bfea7e3d
--- /dev/null
+++ b/src-md/core/crypto/signatures/schnorr-BIP340.md
@@ -0,0 +1,42 @@
+# Schnorr Signatures (BIP340) — `schnorr-BIP340.js`
+
+Implements [BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) Schnorr signatures for the `secp256k1` curve and includes Taproot-oriented utilities. The module exposes helpers for signing, verification and key recovery with hardened input validation.
+
+Highlights:
+
+- 📏 Fixed 64‑byte signature format
+- 🔑 Support for x-only public keys
+- 🔒 Built‑in `SchnorrError` and `SchnorrValidator` classes
+
+---
+
+## 🧪 Examples
+
+### Sign and Verify
+```js
+import Schnorr from './schnorr-BIP340.js';
+
+const sig = await Schnorr.sign('K...', 'message');
+const ok = await Schnorr.verify(sig, 'message', publicKey);
+```
+
+### Get Public Key From WIF
+```js
+const pub = await Schnorr.retrieve_public_key('K...');
+```
+
+---
+
+## 🧠 API Reference
+
+### `Schnorr.sign(privateKey, message, auxRand?)`
+Returns a 64‑byte signature. `privateKey` may be WIF or raw.
+
+### `Schnorr.verify(signature, message, publicKey)`
+Checks a signature against a message and x-only public key.
+
+### `Schnorr.retrieve_public_key(privateKey)`
+Derives the x-only public key from a private key.
+
+**Exports:** `SchnorrError`, `SchnorrValidator`, `EnhancedSchnorr` (as `Enhanced`), constants, and default object `Schnorr`.
+
diff --git a/src-md/core/crypto/signatures/threshold/polynomial.md b/src-md/core/crypto/signatures/threshold/polynomial.md
new file mode 100644
index 0000000000000000000000000000000000000000..10dfc22165deafeb6e3905bdddcf9624549ef46d
--- /dev/null
+++ b/src-md/core/crypto/signatures/threshold/polynomial.md
@@ -0,0 +1,116 @@
+# Polynomial Operations for Secret Sharing — `Polynomial`
+
+This module implements **finite field polynomial arithmetic** over the secp256k1 curve order. It's optimized for cryptographic schemes like **Shamir’s Secret Sharing**, **threshold signatures**, and **secure key splitting**.
+
+> Uses [BN.js](https://github.com/indutny/bn.js/) for big number math and operates modulo `secp256k1` curve order.
+
+---
+
+## ✨ Features
+
+- 🎲 Cryptographically secure random polynomial generation
+- 📈 Polynomial evaluation using **Horner’s method**
+- 🔁 **Lagrange interpolation** to reconstruct secrets from shares
+- ➕ Polynomial addition (f + g)
+- ✖️ Polynomial multiplication (f × g)
+
+---
+
+## 🔧 Usage
+
+### Create a Random Polynomial
+```js
+const poly = Polynomial.fromRandom(2); // Degree 2 => 3-of-N threshold
+```
+
+### Generate Shares
+```js
+const shares = [1, 2, 3, 4, 5].map(x => [x, poly.evaluate(x)]);
+```
+
+### Reconstruct Secret from Shares
+```js
+const secret = Polynomial.interpolate_evaluate(shares.slice(0, 3), 0);
+```
+
+### Add Two Polynomials
+```js
+const f = Polynomial.fromRandom(2);
+const g = Polynomial.fromRandom(2);
+const sum = f.add(g);
+```
+
+### Multiply Two Polynomials
+```js
+const product = f.multiply(g);
+```
+
+---
+
+## 📘 API Reference
+
+### `new Polynomial(coefficients: BN[])`
+Create a polynomial from BigNumber coefficients.
+```js
+const poly = new Polynomial([new BN(3), new BN(2), new BN(1)]); // 3 + 2x + 1x²
+```
+
+---
+
+### `Polynomial.fromRandom(order = 2)`
+Generates a cryptographically secure random polynomial of given degree.
+- **Returns:** `Polynomial`
+- Constant term is the secret.
+
+---
+
+### `poly.evaluate(x)`
+Evaluates the polynomial at a given `x` using Horner’s method.
+- **Returns:** `{BN}` result mod curve order
+
+---
+
+### `Polynomial.interpolate_evaluate(points, x)`
+Performs Lagrange interpolation to reconstruct f(x) from share points.
+- **Parameters:**
+  - `points` `{Array<[number, BN]>}` – Array of `[x, y]` shares
+  - `x` `{number}` – Point at which to evaluate
+- **Returns:** `{BN}` f(x) mod curve order
+
+---
+
+### `poly.add(other)`
+Adds two polynomials coefficient-wise.
+- **Returns:** `Polynomial`
+
+---
+
+### `poly.multiply(other)`
+Multiplies two polynomials via convolution.
+- **Returns:** `Polynomial`
+
+---
+
+## 🧠 Use Case: Shamir Secret Sharing
+```js
+const secret = new BN("deadbeef", "hex");
+const poly = new Polynomial([secret, new BN(123), new BN(456)]); // 2-of-3
+
+// Generate shares
+const shares = [1, 2, 3].map(x => [x, poly.evaluate(x)]);
+
+// Reconstruct from any 2
+const reconstructed = Polynomial.interpolate_evaluate(shares.slice(0, 2), 0);
+console.log(reconstructed.eq(secret)); // true
+```
+
+---
+
+## 📌 Notes
+
+- All operations are performed modulo the `secp256k1` curve order `N`
+- Compatible with ECC-based threshold cryptography and MPC
+
+```diff
++ Use this module to power secure key splitting and threshold wallet infrastructure.
+```
diff --git a/src-md/core/crypto/signatures/threshold/threshold-signature.md b/src-md/core/crypto/signatures/threshold/threshold-signature.md
new file mode 100644
index 0000000000000000000000000000000000000000..1997bbf967d3e9304389e04956466db0ca915b44
--- /dev/null
+++ b/src-md/core/crypto/signatures/threshold/threshold-signature.md
@@ -0,0 +1,41 @@
+# Threshold Signature Scheme — `threshold-signature.js`
+
+Implements a flexible threshold ECDSA scheme inspired by the Nakasendo whitepaper. It uses Shamir's secret sharing and polynomial commitments to allow distributed signing without revealing private keys.
+
+Main characteristics:
+
+- ➗ Splits a master secret across multiple participants
+- 🔐 Nonce manager to prevent reuse and enforce canonical signatures
+- 📜 Polynomial utilities for verifiable secret sharing
+
+---
+
+## 🧪 Example
+
+```js
+import ThresholdSignature from './threshold-signature.js';
+
+const tss = new ThresholdSignature(3, 2); // 2 of 3 scheme
+const shares = tss.generateShares();
+const sig = tss.sign(shares.slice(0, 2), msgHash);
+const ok = tss.verify(sig, msgHash);
+```
+
+---
+
+## 🧠 API Reference
+
+### `new ThresholdSignature(groupSize, threshold)`
+Creates a new scheme instance.
+
+### `generateShares()`
+Returns hex shares for each participant.
+
+### `sign(shares, msgHash)`
+Produces a deterministic ECDSA signature from a subset of shares.
+
+### `verify(signature, msgHash)`
+Validates a threshold signature.
+
+**Exports:** default class `ThresholdSignature`.
+
diff --git a/src-md/core/taproot/control-block.md b/src-md/core/taproot/control-block.md
new file mode 100644
index 0000000000000000000000000000000000000000..01fd2e77984562ca65983707e65da1fcb2c2441c
--- /dev/null
+++ b/src-md/core/taproot/control-block.md
@@ -0,0 +1,36 @@
+# Taproot Control Block — `control-block.js`
+
+Implements BIP341 control block parsing and validation. A control block proves inclusion of a script path inside a Taproot tree and specifies the internal key and parity used to tweak the output key.
+
+Highlights:
+
+- 📄 Extracts leaf version, internal key and merkle path
+- ✔️ Verifies merkle inclusion using `TaprootMerkleTree`
+- 🔐 `ControlBlockError` for structured errors
+
+---
+
+## 🧪 Example
+
+```js
+import { TaprootControlBlock } from './control-block.js';
+
+const cb = new TaprootControlBlock(buffer);
+console.log(cb.leafVersion, cb.merklePath.length);
+```
+
+---
+
+## 🧠 API Reference
+
+### `new TaprootControlBlock(buffer)`
+Parses a serialized control block.
+
+### `verify(targetHash)`
+Checks that the merkle path commits to `targetHash`.
+
+### `getInfo()`
+Returns an object describing version, parity and internal key.
+
+**Exports:** `ControlBlockError`, `ControlBlockSecurityUtils`, `TaprootControlBlock`, `CONTROL_BLOCK_CONSTANTS`.
+
diff --git a/src-md/core/taproot/merkle-tree.md b/src-md/core/taproot/merkle-tree.md
new file mode 100644
index 0000000000000000000000000000000000000000..8312c49142360e81a627ce36dfe0d7c04a4778ae
--- /dev/null
+++ b/src-md/core/taproot/merkle-tree.md
@@ -0,0 +1,39 @@
+# Taproot Merkle Tree — `merkle-tree.js`
+
+Builds and verifies Taproot script trees as described in [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki). Provides tagged hashing for leaves and branches and deterministic lexicographic ordering.
+
+Features:
+
+- 🌲 Create TapLeaf and TapBranch hashes
+- 🔗 Generate merkle paths for inclusion proofs
+- 🧹 Secure memory cleanup helpers
+
+---
+
+## 🧪 Example
+
+```js
+import { TaprootMerkleTree } from './merkle-tree.js';
+
+const tree = new TaprootMerkleTree([
+  Buffer.from('51'),      // OP_TRUE leaf
+  Buffer.from('6a'),      // OP_RETURN leaf
+]);
+console.log(tree.root.toString('hex'));
+```
+
+---
+
+## 🧠 API Reference
+
+### `new TaprootMerkleTree(scripts, leafVersion = 0xc0)`
+Creates a tree from an array of script buffers.
+
+### `getMerklePath(leafIndex)`
+Returns `{hashes, directions}` arrays proving inclusion of a leaf.
+
+### `destroy()`
+Securely wipes all internal buffers.
+
+**Exports:** `MerkleTreeError`, `MerkleSecurityUtils`, `TaggedHash`, `TaprootMerkleTree`, `MERKLE_CONSTANTS`.
+
diff --git a/src-md/core/taproot/tapscript-interpreter.md b/src-md/core/taproot/tapscript-interpreter.md
new file mode 100644
index 0000000000000000000000000000000000000000..8ee4b74fdede42950de467b811c2615a8d332464
--- /dev/null
+++ b/src-md/core/taproot/tapscript-interpreter.md
@@ -0,0 +1,36 @@
+# Tapscript Interpreter — `tapscript-interpreter.js`
+
+Implements a minimal interpreter for the [BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki) Tapscript rules. It handles modified opcodes, signature budgets and success paths used in Taproot script validation.
+
+Highlights:
+
+- 🧮 Executes Tapscript with configurable resource limits
+- 🔑 Integrates Schnorr signature verification
+- 🛡️ `TapscriptError` for detailed failures
+
+---
+
+## 🧪 Example
+
+```js
+import { TapscriptInterpreter } from './tapscript-interpreter.js';
+
+const ctx = new TapscriptInterpreter();
+ctx.execute(witnessStack, script, controlBlock);
+```
+
+---
+
+## 🧠 API Reference
+
+### `new TapscriptInterpreter(options?)`
+Creates an interpreter instance with optional limits.
+
+### `execute(stack, script, controlBlock)`
+Runs the script against a witness stack and control block.
+
+### `getStatus()`
+Returns internal metrics such as consumed budget.
+
+**Exports:** `TapscriptError`, `TapscriptSecurityUtils`, `TapscriptExecutionContext`, `TapscriptInterpreter`, `TAPSCRIPT_CONSTANTS`, `OPCODES`.
+
diff --git a/src-md/encoding/address/decode.md b/src-md/encoding/address/decode.md
new file mode 100644
index 0000000000000000000000000000000000000000..5ee502801dedbf8e5e6a9cb56bc234a62ec6e5f3
--- /dev/null
+++ b/src-md/encoding/address/decode.md
@@ -0,0 +1,82 @@
+# Bitcoin Address Utility Module
+
+## Overview
+
+This module provides utility functions for handling Bitcoin addresses, including:
+
+- **Base58Check address decoding**
+- **Bit-width conversion** for Bech32/Base32 compatibility
+- **Checksum formatting** for Base32 encoding
+
+These functions are typically used in the construction and parsing of both legacy and SegWit (Bech32) Bitcoin addresses.
+
+---
+
+## Functions
+
+### `decode_legacy_address(legacy_addr: string): [string, string]`
+
+Decodes a Base58Check Bitcoin address and extracts network info and HASH160.
+
+**Parameters:**
+- `legacy_addr` (string): Legacy P2PKH Bitcoin address
+
+**Returns:**
+- `[network_prefix, hash160]` as an array
+
+**Example:**
+```js
+const [prefix, hash] = decode_legacy_address("1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2");
+// prefix = "bc", hash = "76a04053bda0a88bda5177b86a15c3b29f559873"
+```
+
+---
+
+### `convertBits(data: Uint8Array, from: number, to: number): Uint8Array`
+
+Converts a buffer of data from one bit width to another (e.g. 8 → 5 or 5 → 8). This is essential for encoding addresses in Bech32 format.
+
+**Parameters:**
+- `data` (Uint8Array): Input data
+- `from` (number): Original bit size (usually 8)
+- `to` (number): Desired bit size (e.g., 5)
+
+**Returns:**
+- Converted `Uint8Array` with new bit-width
+
+**Example:**
+```js
+const fiveBit = convertBits(new Uint8Array([0xFF, 0x80, 0x00]), 8, 5);
+// [31, 30, 0, 0, 0]
+```
+
+---
+
+### `checksum_5bit(checksum: number): Uint8Array`
+
+Encodes a numeric checksum into 8 × 5-bit format (for Bech32).
+
+**Parameters:**
+- `checksum` (number): Typically 10-digit checksum from Bech32
+
+**Returns:**
+- `Uint8Array` of 8 values, each a 5-bit segment
+
+**Example:**
+```js
+const arr = checksum_5bit(0x1234567890);
+// Uint8Array [16, 18, 6, 22, 15, 4, 18, 0]
+```
+
+---
+
+## Dependencies
+
+- `base58-js`: Used for Base58Check decoding.
+- Standard Node.js `Buffer` API
+
+---
+
+## License
+
+MIT License © yfbsei
diff --git a/src-md/encoding/address/encode.md b/src-md/encoding/address/encode.md
new file mode 100644
index 0000000000000000000000000000000000000000..944a5cc57354ce2bcff1f2a3af0948f9847d8159
--- /dev/null
+++ b/src-md/encoding/address/encode.md
@@ -0,0 +1,307 @@
+# Bitcoin Key Encoding Utilities
+
+This module provides comprehensive encoding functions for Bitcoin cryptographic keys and addresses. It handles the conversion of raw key material into standardized formats used across the Bitcoin ecosystem, including extended keys (BIP32), Wallet Import Format (WIF), and Base58Check addresses.
+
+## Overview
+
+- **Module Name:** Key Encoding Utilities
+- **Author:** yfbsei
+- **Version:** 2.0.0
+- **Related Specifications:**
+  - [BIP32 – Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
+  - [WIF – Wallet Import Format](https://en.bitcoin.it/wiki/Wallet_import_format)
+  - [Bitcoin Address Format](https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses)
+
+## Constants
+
+### `NETWORK_VERSIONS`
+
+```js
+const NETWORK_VERSIONS = {
+  MAINNET: {
+    EXTENDED_PRIVATE: 0x0488ade4,
+    EXTENDED_PUBLIC:  0x0488b21e,
+    WIF_PRIVATE:      0x80,
+    ADDRESS_P2PKH:    0x00
+  },
+  TESTNET: {
+    EXTENDED_PRIVATE: 0x04358394,
+    EXTENDED_PUBLIC:  0x043587cf,
+    WIF_PRIVATE:      0xef,
+    ADDRESS_P2PKH:    0x6f
+  }
+};
+```
+
+Defines version bytes used for extended keys, WIF private keys, and P2PKH address prefixes on both mainnet and testnet.
+
+## API Reference
+
+---
+
+### `hdKey(keyType, params)`
+
+Encodes hierarchical deterministic keys according to the BIP32 specification. Creates extended keys (xprv/xpub, tprv/tpub) that encapsulate key material and metadata required for child derivation.
+
+- **Signature:**
+  ```js
+  hdKey(keyType = 'pri', params = {});
+  ```
+
+- **Parameters:**
+  - `keyType` `string`  
+    `'pri'` for extended private key or `'pub'` for extended public key.
+  - `params` `Object`  
+    Serialization parameters (all fields optional unless otherwise noted):
+    ```js
+    {
+      versionByte: {
+        privKey: <number>,  // EXTENDED_PRIVATE version (required if keyType = 'pri')
+        pubKey:  <number>   // EXTENDED_PUBLIC version (required)
+      },
+      depth:              <number>,   // Derivation depth (default: 0)
+      parentFingerPrint:  <Buffer>,   // 4-byte parent fingerprint (default: 0x00000000)
+      childIndex:         <number>,   // Child index (default: 0)
+      chainCode:          <Buffer>,   // 32-byte chain code (default: 0x00...00)
+      privKey: {
+        key:           <Buffer>,      // 32-byte private key (required if keyType = 'pri')
+        versionByteNum:<number>       // WIF version byte (0x80 mainnet, 0xef testnet)
+      },
+      pubKey: {
+        key:           <Buffer>,      // 33-byte compressed public key (required)
+        points?:       <Point>        // Optional elliptic curve point representation
+      }
+    }
+    ```
+
+- **Returns:**  
+  `string` — A Base58Check-encoded extended key (e.g., xprv..., xpub..., tprv..., tpub...).
+
+- **Throws:**
+  - `Error` if `keyType` is not `'pri'` or `'pub'`.
+  - `Error` if required key information is missing for the specified `keyType`.
+  - `Error` if serialization parameters are invalid or malformed.
+
+- **Examples:**
+
+  ```js
+  // 1) Create a master extended private key (xprv) for Bitcoin mainnet
+  const masterFormat = {
+    versionByte: {
+      privKey: NETWORK_VERSIONS.MAINNET.EXTENDED_PRIVATE,
+      pubKey:  NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC
+    },
+    depth: 0,
+    parentFingerPrint: Buffer.alloc(4, 0),
+    childIndex: 0,
+    chainCode: Buffer.from('873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508', 'hex'),
+    privKey: {
+      key: Buffer.from('e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex'),
+      versionByteNum: NETWORK_VERSIONS.MAINNET.WIF_PRIVATE
+    },
+    pubKey: {
+      key: Buffer.from('0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2', 'hex')
+    }
+  };
+
+  const xprv = hdKey('pri', masterFormat);
+  console.log(xprv);
+  // => "xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJU..."
+
+  // 2) Create the corresponding extended public key (xpub)
+  const xpub = hdKey('pub', masterFormat);
+  console.log(xpub);
+  // => "xpub661MyMwAqRbcFtXgS5sYJABqq..."
+
+  // 3) Generate testnet extended keys
+  const testnetFormat = {
+    ...masterFormat,
+    versionByte: {
+      privKey: NETWORK_VERSIONS.TESTNET.EXTENDED_PRIVATE,
+      pubKey:  NETWORK_VERSIONS.TESTNET.EXTENDED_PUBLIC
+    }
+  };
+
+  const tprv = hdKey('pri', testnetFormat);
+  const tpub = hdKey('pub', testnetFormat);
+  console.log(tprv.slice(0, 4)); // "tprv"
+  console.log(tpub.slice(0, 4)); // "tpub"
+
+  // 4) Example for a child key at depth 3 (hardened)
+  const childFormat = {
+    versionByte: {
+      privKey: NETWORK_VERSIONS.MAINNET.EXTENDED_PRIVATE,
+      pubKey:  NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC
+    },
+    depth: 3,
+    parentFingerPrint: Buffer.from([0x5c, 0x1b, 0xd6, 0x48]),
+    childIndex: 2147483647, // hardened index (2^31 - 1)
+    chainCode: Buffer.from('47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141', 'hex'),
+    privKey: {
+      key: Buffer.from('cbce0d719ecf7431d88e6a89fa1483e02e35092af60c042b1df2ff59fa424dca', 'hex'),
+      versionByteNum: NETWORK_VERSIONS.MAINNET.WIF_PRIVATE
+    },
+    pubKey: {
+      key: Buffer.from('0357bfe1e341d01c69fe5654309956cbea516822fba8a601743a012a7896ee8dc2', 'hex')
+    }
+  };
+
+  const childXprv = hdKey('pri', childFormat);
+  console.log(childXprv);
+  // => Extended key reflecting depth = 3 and hardened child index
+  ```
+
+---
+
+### `standardKey(privKey, pubKey)`
+
+Encodes private and public keys in standard Bitcoin formats:
+
+- **WIF (Wallet Import Format)** for private keys (with compression flag).
+- **Hex encoding** for public keys in compressed format.
+
+- **Signature:**
+  ```js
+  standardKey(privKey = false, pubKey = null);
+  ```
+
+- **Parameters:**
+  - `privKey` `PrivateKeyInfo | false`  
+    - If an object, it must have:
+      ```js
+      {
+        key:           <Buffer>,   // 32-byte private key
+        versionByteNum:<number>    // WIF version byte (0x80 mainnet, 0xef testnet)
+      }
+      ```
+    - If `false`, skip private key encoding (public‐only).
+  - `pubKey` `PublicKeyInfo | null`  
+    - If an object, it must have:
+      ```js
+      {
+        key: <Buffer>  // 33-byte compressed public key
+      }
+      ```
+    - `null` or missing means no public key encoding.
+
+- **Returns:**  
+  `StandardKeyPair` object:
+  ```js
+  {
+    pri: <string|null>,  // WIF-encoded private key, or null if not provided
+    pub: <string>        // Hex-encoded compressed public key
+  }
+  ```
+
+- **Examples:**
+
+  ```js
+  // 1) Encode both private and public keys for Bitcoin mainnet
+  const privKeyInfo = {
+    key: Buffer.from('e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex'),
+    versionByteNum: NETWORK_VERSIONS.MAINNET.WIF_PRIVATE
+  };
+
+  const pubKeyInfo = {
+    key: Buffer.from('0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2', 'hex')
+  };
+
+  const keyPair = standardKey(privKeyInfo, pubKeyInfo);
+  console.log(keyPair.pri);
+  // => "L5HgWvFghocq1FmxSjKNaGhVN8f67p6xYg5pY7M8FE77HXwHtGGu"
+  console.log(keyPair.pub);
+  // => "0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2"
+
+  // 2) Encode only public key (watch-only)
+  const publicOnly = standardKey(false, pubKeyInfo);
+  console.log(publicOnly.pri); // null
+  console.log(publicOnly.pub); // "0339a360..."
+
+  // 3) Testnet WIF private key encoding
+  const testnetPrivKey = {
+    key: Buffer.from('e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex'),
+    versionByteNum: NETWORK_VERSIONS.TESTNET.WIF_PRIVATE
+  };
+
+  const testnetKeys = standardKey(testnetPrivKey, pubKeyInfo);
+  console.log(testnetKeys.pri);
+  // => "cTNsJG5wZ3CZUKCy3vSHzXJHrR4eo2C3RKqR8YbdQQVQH4Tb6nHy"
+  ```
+
+---
+
+### `address(versionByte, pubKey)`
+
+Generates a Bitcoin P2PKH address from a compressed public key. Implements HASH160 (SHA256 + RIPEMD160) plus Base58Check encoding.
+
+- **Signature:**
+  ```js
+  address(versionByte = NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC, pubKey);
+  ```
+
+- **Parameters:**
+  - `versionByte` `number`  
+    Use either `NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC` (for mainnet) or `NETWORK_VERSIONS.TESTNET.EXTENDED_PUBLIC` (for testnet). Internally maps to P2PKH prefixes `0x00` or `0x6f`.
+  - `pubKey` `Buffer`  
+    33-byte compressed public key.
+
+- **Returns:**  
+  `string` — Base58Check-encoded P2PKH address (e.g., starting with '1' on mainnet or 'm/n' on testnet).
+
+- **Throws:**
+  - `Error` if `pubKey` is not a valid `Buffer` of length 33.
+  - `Error` if `versionByte` is not recognized.
+
+- **Examples:**
+
+  ```js
+  // 1) Generate a mainnet P2PKH address
+  const pubKey = Buffer.from('0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2', 'hex');
+  const mainnetVersionByte = NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC;
+
+  const addressMain = address(mainnetVersionByte, pubKey);
+  console.log(addressMain);
+  // => "15mKKb2eos1hWa6tisdPwwDC1a5J1y9nma"
+
+  // 2) Generate a testnet P2PKH address
+  const testnetVersionByte = NETWORK_VERSIONS.TESTNET.EXTENDED_PUBLIC;
+  const addressTest = address(testnetVersionByte, pubKey);
+  console.log(addressTest);
+  // => "mhiH7BQkmD7LoosHhAAH5nE9YKGUcPz4hV"
+
+  // 3) Full workflow: private key → public key → address
+  import { getPublicKey } from '@noble/secp256k1';
+
+  const privateKey = Buffer.from('e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex');
+  const publicKey = Buffer.from(getPublicKey(privateKey, true));  // compressed
+  const btcAddress = address(NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC, publicKey);
+
+  console.log('Private key:', privateKey.toString('hex'));
+  console.log('Public key:', publicKey.toString('hex'));
+  console.log('Address:   ', btcAddress);
+
+  // 4) Verify against known test vector
+  const knownPubKey = Buffer.from('0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798', 'hex');
+  const knownAddress = address(NETWORK_VERSIONS.MAINNET.EXTENDED_PUBLIC, knownPubKey);
+  console.log(knownAddress);
+  // => "1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH" (matches standard example)
+  ```
+
+---
+
+## Security Considerations
+
+- **Extended Private Keys (xprv/tprv)** contain both private key and chain code—treat with utmost confidentiality.
+- **Chain Code** must remain secret; exposure allows derivation of child keys.
+- **Extended Public Keys (xpub/tpub)** enable non-hardened child public key derivation—share only with trusted parties.
+- **WIF Private Keys** must be stored securely (e.g., hardware wallets, encrypted storage) and never logged.
+- **Address Generation** is deterministic—reuse reduces privacy; use hierarchical deterministic paths for fresh addresses per transaction.
+
+## Performance Notes
+
+- **hdKey Serialization:** ~0.1ms (buffer operations)
+- **Base58Check Encoding:** ~0.5ms (checksum + encoding)
+- **WIF Encoding:** ~0.8ms
+- **Address Generation (HASH160 + Base58Check):** ~0.8ms
+- Results may be cached for hot paths in wallet applications.
+
diff --git a/src-md/encoding/base32.md b/src-md/encoding/base32.md
new file mode 100644
index 0000000000000000000000000000000000000000..83a2cdc2a83d835f967786abea77d52ac8b8abc6
--- /dev/null
+++ b/src-md/encoding/base32.md
@@ -0,0 +1,135 @@
+# Base32 Encoder for Bitcoin Address Formats
+
+A minimal, standards-compliant JavaScript encoder for Base32 as defined by Bitcoin’s [BIP173 (Bech32)](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) and [CashAddr](https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md) specifications.  
+Unlike RFC 4648 Base32, this implementation uses a Bitcoin-specific alphabet optimized for **human readability** and **error detection**.
+
+---
+
+## 📦 Features
+
+- ⚡ Fast, simple encoding of 5-bit values to Base32
+- 🔒 Secure input validation
+- 🧠 Human-readable, non-ambiguous characters
+- ✅ Compliant with BIP173 & CashAddr
+- 🔄 Supports use cases like address encoding and checksums
+
+---
+
+## 🔤 Alphabet (CHARSET)
+
+```
+qpzry9x8gf2tvdw0s3jn54khce6mua7l
+```
+
+| Char | Index | Char | Index | Char | Index | Char | Index |
+|------|-------|------|-------|------|-------|------|-------|
+| q    | 0     | p    | 1     | z    | 2     | r    | 3     |
+| y    | 4     | 9    | 5     | x    | 6     | 8    | 7     |
+| g    | 8     | f    | 9     | 2    | 10    | t    | 11    |
+| v    | 12    | d    | 13    | w    | 14    | 0    | 15    |
+| s    | 16    | 3    | 17    | j    | 18    | n    | 19    |
+| 5    | 20    | 4    | 21    | k    | 22    | h    | 23    |
+| c    | 24    | e    | 25    | 6    | 26    | m    | 27    |
+| u    | 28    | a    | 29    | 7    | 30    | l    | 31    |
+
+---
+
+## 🚀 Usage
+
+### `base32_encode(data: Uint8Array | number[]): string`
+
+Encodes an array of 5-bit integers (0–31) to a Base32 string using the Bitcoin alphabet.
+
+### Parameters
+
+| Name | Type                     | Description                      |
+|------|--------------------------|----------------------------------|
+| data | `Uint8Array \| number[]` | Array of values (0–31 only)      |
+
+### Returns
+
+`string` – Base32-encoded string
+
+### Throws
+
+- If input is empty
+- If any value is not between 0 and 31
+
+---
+
+## 💡 Examples
+
+### Encode simple array
+
+```js
+const data = new Uint8Array([0, 1, 2, 3, 4, 5]);
+console.log(base32_encode(data)); // "qpzry9"
+```
+
+### Encode Bech32 Payload
+
+```js
+const payload = new Uint8Array([
+  0, 14, 8, 20, 6, 2, 8, 4, 21, 15, 12, 1, 1, 9, 25, 4,
+  11, 3, 23, 26, 10, 0, 31, 1, 15, 13, 26, 8, 21, 23, 4, 11, 2, 16
+]);
+console.log(base32_encode(payload));
+// → "qw508d6qejxtdg4y5r3zarvary0c5xw7k"
+```
+
+### Encode checksum
+
+```js
+const checksum = new Uint8Array([21, 15, 9, 14, 26, 20, 0, 15]);
+console.log(base32_encode(checksum)); // "54n5063"
+```
+
+---
+
+## 🔐 Security Notes
+
+- ❗ Input is validated to avoid encoding errors
+- ✅ Deterministic and reversible with a proper decoder
+- 🚫 Not encryption – this is **encoding only**
+- 🔍 Error detection is handled at a higher level (e.g., Bech32 checksum)
+
+---
+
+## 📈 Performance
+
+- **Time**: Linear (O(n))
+- **Memory**: One string output allocation
+- ⚡ Fast enough for wallet applications and address tools
+
+---
+
+## 🧪 Example Test
+
+```js
+function validateEncoding() {
+  const test = new Uint8Array(32).map(() => Math.floor(Math.random() * 32));
+  const encoded = base32_encode(test);
+
+  for (const char of encoded) {
+    if (!CHARSET.includes(char)) {
+      throw new Error(`Invalid character: ${char}`);
+    }
+  }
+
+  console.log("✓ Passed");
+}
+```
+
+---
+
+## 🧾 License
+
+MIT © 2024 yfbsei
+
+---
+
+## 📚 References
+
+- [BIP-0173: Bech32 Format](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)
+- [CashAddr Spec](https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md)
+- [Bitcoin Wiki – Address Formats](https://en.bitcoin.it/wiki/Bech32)
\ No newline at end of file
diff --git a/src-md/encoding/base58.md b/src-md/encoding/base58.md
new file mode 100644
index 0000000000000000000000000000000000000000..c59496a7d4e4091dffa2b3e5c500d4225e71bdb7
--- /dev/null
+++ b/src-md/encoding/base58.md
@@ -0,0 +1,94 @@
+
+# Base58Check Encoding for Bitcoin
+
+This module implements **Base58Check encoding**, a checksummed base58 encoding format used extensively in Bitcoin for addresses, private keys (WIF), and extended keys (xpub/xprv). It ensures human-readable output with built-in error detection via a double SHA256 checksum.
+
+## 📜 Description
+
+- Encodes binary data using Bitcoin's Base58 alphabet
+- Appends 4-byte checksum (double SHA256) before encoding
+- Ensures high error detection (1 in 4.3 billion chance of undetected corruption)
+
+---
+
+## 🧪 Examples
+
+### Encode WIF Private Key
+
+```js
+const privateKeyBytes = Buffer.concat([
+  Buffer.from([0x80]),
+  Buffer.from('e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex'),
+  Buffer.from([0x01])
+]);
+console.log(b58encode(privateKeyBytes));
+// → "L5HgWvFghocq1FmxSjKNaGhVN8f67p6xYg5pY7M8FE77HXwHtGGu"
+```
+
+### Encode Bitcoin Address
+
+```js
+const hash160 = Buffer.from('76a04053bda0a88bda5177b86a15c3b29f559873', 'hex');
+const addressBytes = Buffer.concat([
+  Buffer.from([0x00]),  // Mainnet prefix
+  hash160
+]);
+console.log(b58encode(addressBytes));
+// → "1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH"
+```
+
+### Extended Key (xpub)
+
+```js
+const extendedKeyData = Buffer.concat([
+  Buffer.from([0x04, 0x88, 0xb2, 0x1e]),
+  Buffer.from([0x00]),
+  Buffer.alloc(4, 0),
+  Buffer.alloc(4, 0),
+  Buffer.from('873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508', 'hex'),
+  Buffer.from('0339a36013301597daef41fbe593a02cc513d0b55527ec2df1050e2e8ff49c85c2', 'hex')
+]);
+console.log(b58encode(extendedKeyData));
+// → "xpub661MyMwAqRbcFtXgS5sYJABqqG9..."
+```
+---
+
+## 📚 API Reference
+
+### `b58encode(buffer: Buffer): string`
+
+Encodes a binary buffer to a Base58Check string.
+
+#### Parameters
+- `buffer` *(Buffer)*: Binary data to encode
+
+#### Returns
+- *(string)*: Base58Check-encoded string
+
+#### Throws
+- If input is not a `Buffer`
+- If Base58 encoding fails (rare)
+
+---
+
+## 🔐 Security
+
+- Uses **double SHA256 checksum** to detect transmission errors
+- Common single-character mistakes are always detected
+- **Not encryption** — only integrity protection
+- Always validate checksum during decoding
+
+---
+
+## 📖 References
+
+- [Bitcoin Wiki - Base58Check](https://en.bitcoin.it/wiki/Base58Check_encoding)
+- [RFC 4648 - Base Encodings](https://tools.ietf.org/html/rfc4648)
+
+---
+
+## 🧑‍💻 Author
+
+**yfbsei**  
+Version: 1.0.0  
+MIT License
diff --git a/src-md/transaction/builder.md b/src-md/transaction/builder.md
new file mode 100644
index 0000000000000000000000000000000000000000..b6f52c8d5faf6e40ceb06af312eeb7eef8fd61a6
--- /dev/null
+++ b/src-md/transaction/builder.md
@@ -0,0 +1,41 @@
+# Transaction Builder — `builder.js`
+
+Creates immutable Bitcoin transactions using a PSBT-first workflow. Supports legacy, SegWit and Taproot inputs with automatic fee estimation and change output generation.
+
+Features:
+
+- 🧱 Add inputs/outputs while keeping previous versions immutable
+- 🏷️ Generate PSBT data for external signing
+- 🔄 RBF fee bumping helpers
+
+---
+
+## 🧪 Example
+
+```js
+import { TransactionBuilder } from './builder.js';
+
+const txb = new TransactionBuilder('main');
+txb.addInput(prevTxId, 0);
+txb.addOutput(address, 10000);
+const psbt = txb.export();
+```
+
+---
+
+## 🧠 API Reference
+
+### `new TransactionBuilder(network)`
+Constructs a builder for `network` (`'main'` or `'test'`).
+
+### `addInput(txid, vout, sequence?)`
+Appends an input to the transaction.
+
+### `addOutput(address, value)`
+Appends an output in satoshis.
+
+### `export()`
+Returns the underlying PSBT object.
+
+**Exports:** `TransactionBuilderError`, `TransactionSecurityUtils`, `TransactionBuilder`, `TRANSACTION_CONSTANTS`.
+
diff --git a/src-md/transaction/psbt.md b/src-md/transaction/psbt.md
new file mode 100644
index 0000000000000000000000000000000000000000..58cce4a6b791774ccf6114364170d0ab1614fb5c
--- /dev/null
+++ b/src-md/transaction/psbt.md
@@ -0,0 +1,41 @@
+# Partially Signed Bitcoin Transactions — `psbt.js`
+
+Simplified PSBT processor implementing the essentials of [BIP174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki). The class manages PSBT fields, signing, and finalization with optional Taproot extensions.
+
+Key features:
+
+- ✍️ Append or combine PSBT inputs/outputs
+- 🔑 Sign with ECDSA or Schnorr modules
+- 🔗 Export final transactions for broadcast
+
+---
+
+## 🧪 Example
+
+```js
+import { EnhancedPSBT } from './psbt.js';
+
+const psbt = new EnhancedPSBT('main');
+psbt.addInput({...});
+psbt.addOutput({...});
+const finalTx = psbt.finalize();
+```
+
+---
+
+## 🧠 API Reference
+
+### `new EnhancedPSBT(network)`
+Creates an empty PSBT for the given network.
+
+### `addInput(input)` / `addOutput(output)`
+Modifies the PSBT with new data.
+
+### `combine(otherPsbt)`
+Merges data from another PSBT instance.
+
+### `finalize()`
+Produces a complete transaction ready to broadcast.
+
+**Exports:** `PSBTError`, `PSBTSecurityUtils`, `PSBT_CONSTANTS`, `EnhancedPSBT`.
+
diff --git a/src-md/transaction/utxo-manager.md b/src-md/transaction/utxo-manager.md
new file mode 100644
index 0000000000000000000000000000000000000000..52c30fab4416c810a6e43c8ff54c8c1da9237225
--- /dev/null
+++ b/src-md/transaction/utxo-manager.md
@@ -0,0 +1,36 @@
+# UTXO Manager — `utxo-manager.js`
+
+Handles coin selection and fee estimation for wallets. Implements multiple selection strategies (largest-first, accumulative) and interfaces with the transaction builder for RBF fee bumps.
+
+Key aspects:
+
+- 🎯 Choose UTXOs by value, age or privacy scoring
+- 🔗 Query mempool APIs for fee suggestions
+- 🔄 Consolidation and RBF helper methods
+
+---
+
+## 🧪 Example
+
+```js
+import { UTXOManager } from './utxo-manager.js';
+
+const mgr = new UTXOManager(utxos);
+const { inputs, change } = await mgr.selectForAmount(50000);
+```
+
+---
+
+## 🧠 API Reference
+
+### `new UTXOManager(utxoList)`
+Creates a manager with an initial set of UTXOs.
+
+### `selectForAmount(value, strategy?)`
+Returns `{inputs, change}` sufficient to fund `value`.
+
+### `estimateFeeRate()`
+Fetches current fee recommendations.
+
+**Exports:** `UTXOManagerError`, `UTXOSecurityUtils`, `UTXOSelectionStrategies`, `FeeEstimationService`, `UTXOManager`, `UTXO_CONSTANTS`.
+
diff --git a/src-md/utils/address-helpers.md b/src-md/utils/address-helpers.md
new file mode 100644
index 0000000000000000000000000000000000000000..a64ad8825be631fca92e9061abe7610aa6687c19
--- /dev/null
+++ b/src-md/utils/address-helpers.md
@@ -0,0 +1,36 @@
+# Address Utilities — `address-helpers.js`
+
+Collection of helper functions for encoding and validating traditional Base58Check addresses. Includes bit-conversion helpers used by the Bech32 module and network detection utilities.
+
+Capabilities:
+
+- 🔍 Decode legacy addresses and verify checksums
+- 🔄 Convert 8‑bit groups to 5‑bit for Bech32 encoding
+- 🛡️ Security helpers such as constant-time comparisons
+
+---
+
+## 🧪 Example
+
+```js
+import { decodeLegacyAddress } from './address-helpers.js';
+
+const info = decodeLegacyAddress('1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa');
+console.log(info.addressType); // 'P2PKH'
+```
+
+---
+
+## 🧠 API Reference
+
+### `decodeLegacyAddress(address)`
+Returns `{ prefix, hash160Hex, addressType }`.
+
+### `convertBitGroups(data, fromBits, toBits, pad?)`
+Converts arrays between bit widths.
+
+### `getNetworkFromAddress(address)`
+Detects the Bitcoin network from a legacy address.
+
+**Exports:** `AddressUtilError`, `AddressSecurityUtils`, `SECURITY_CONSTANTS`, `decodeLegacyAddress`, `convertBitGroups`, `convertChecksumTo5Bit`, `validateAndDecodeLegacyAddress`, `detectAddressFormat`, `normalizeAddress`, `compareAddresses`, `getNetworkFromAddress`, `isAddressForNetwork`, `getAddressUtilsStatus`, `validateImplementation`.
+
diff --git a/src-md/utils/validation.md b/src-md/utils/validation.md
new file mode 100644
index 0000000000000000000000000000000000000000..1b384cd0f2a1fd74dfc4a1c87bc2df54922467b3
--- /dev/null
+++ b/src-md/utils/validation.md
@@ -0,0 +1,39 @@
+# Validation Utilities — `validation.js`
+
+Contains a set of reusable validation helpers for addresses, keys and BIP39 mnemonics. Functions use constant‑time comparisons and rate limiting to avoid timing attacks.
+
+Highlights:
+
+- ✔️ Validate WIF keys and address formats
+- 📏 Check derivation paths and threshold parameters
+- 🧰 Secure random helpers for test vectors
+
+---
+
+## 🧪 Example
+
+```js
+import { validatePrivateKey, validateAddress } from './validation.js';
+
+assertValid(validatePrivateKey('K...'));
+assertValid(validateAddress('bc1q...'));
+```
+
+---
+
+## 🧠 API Reference
+
+### `validatePrivateKey(wif)`
+Returns `{ ok, error }` after checking Base58 checksum.
+
+### `validateAddress(addr)`
+Detects network and verifies checksum.
+
+### `validateMnemonic(words)`
+Validates BIP39 mnemonic phrases.
+
+### `assertValid(result)`
+Throws `ValidationError` if `result.ok` is false.
+
+**Exports:** `ValidationError`, `ValidationSecurityUtils`, `SECURITY_CONSTANTS`, `validateNetwork`, `validateHexString`, `validatePrivateKey`, `validateWIFPrivateKey`, `validateDerivationPath`, `validateThresholdParams`, `validateMnemonic`, `validateAddress`, `validateBufferLength`, `validateNumberRange`, `assertValid`, `getValidationStatus`.
+
diff --git a/src-md/wallet/custodial.md b/src-md/wallet/custodial.md
new file mode 100644
index 0000000000000000000000000000000000000000..94545159bab3a69796367a0e7731825b1eba611d
--- /dev/null
+++ b/src-md/wallet/custodial.md
@@ -0,0 +1,39 @@
+# Custodial Wallet — `custodial.js`
+
+Provides a traditional single-user HD wallet built on BIP32/BIP39. Keys are stored locally and standard ECDSA signatures are used for spending. The module integrates with the transaction builder and UTXO manager.
+
+Key features:
+
+- 🔐 Deterministic key derivation from a master seed
+- 💼 Simple signing and verification helpers
+- 🛡️ Optional passphrase encryption and secure memory wiping
+
+---
+
+## 🧪 Example
+
+```js
+import Custodial_Wallet from './custodial.js';
+
+const [keys, fmt] = generateMasterKey(seedHex, 'main');
+const wallet = new Custodial_Wallet('main', keys, fmt);
+console.log(wallet.address);
+```
+
+---
+
+## 🧠 API Reference
+
+### `new Custodial_Wallet(network, masterKeys, format)`
+Creates a wallet instance using master keys from `master-key.js`.
+
+### `sign(message)`
+Returns an ECDSA signature for the provided message.
+
+### `verify(signature, message)`
+Verifies a signature using the wallet's public key.
+
+### `getSummary()`
+Returns network, address and derivation information.
+
+**Exports:** default class `Custodial_Wallet`.
diff --git a/src-md/wallet/non-custodial.md b/src-md/wallet/non-custodial.md
new file mode 100644
index 0000000000000000000000000000000000000000..e134348473407d4c4055a84344e069eaa86a868d
--- /dev/null
+++ b/src-md/wallet/non-custodial.md
@@ -0,0 +1,39 @@
+# Threshold Wallet — `non-custodial.js`
+
+Implements a multi-party threshold wallet where signing keys are never held in a single location. Built on top of the threshold signature scheme and Taproot utilities.
+
+Highlights:
+
+- 👥 Distributed key generation and signing
+- 🔑 Shares can be combined to reconstruct the private key when needed
+- 🛡️ Rate limiting and secure memory cleanup
+
+---
+
+## 🧪 Example
+
+```js
+import Non_Custodial_Wallet from './non-custodial.js';
+
+const wallet = new Non_Custodial_Wallet('main', 3, 2); // 2-of-3
+console.log(wallet.address);
+```
+
+---
+
+## 🧠 API Reference
+
+### `new Non_Custodial_Wallet(network, groupSize, threshold)`
+Creates a wallet instance with the given parameters.
+
+### `sign(message)`
+Returns a threshold signature using available shares.
+
+### `verify(signature, message)`
+Verifies a threshold signature.
+
+### `getSummary()`
+Returns an object describing network and participant information.
+
+**Exports:** default class `Non_Custodial_Wallet`.
+
