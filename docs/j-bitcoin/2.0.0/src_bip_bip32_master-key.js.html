<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/bip/bip32/master-key.js - J-Bitcoin - Bitcoin Wallet Library</title>
    
    <meta name="description" content="JavaScript/TypeScript Bitcoin wallet library with HD wallets, threshold signatures, and BIP compliance" />
    
        <meta name="keywords" content="bitcoin, btc, cryptocurrency, wallet, javascript, typescript, threshold signatures, bip32, bip39" />
        <meta name="keyword" content="bitcoin, btc, cryptocurrency, wallet, javascript, typescript, threshold signatures, bip32, bip39" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin" target="_blank" class="menu-item home-link" id="home-link" >üè† Home</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin" target="_blank" class="menu-item github-link" id="github-link" >üìö GitHub</a></h2><h2><a href="https://www.npmjs.com/package/j-bitcoin" target="_blank" class="menu-item npm-link" id="npm-link" >üì¶ NPM</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin/tree/main/examples" target="_blank" class="menu-item examples-link" id="examples-link" >üîß Examples</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin/blob/main/CHANGELOG.md" target="_blank" class="menu-item changelog-link" id="changelog-link" >üìä Changelog</a></h2><h3>Global</h3><ul><li><a href="global.html#BIP_COMPLIANCE">BIP_COMPLIANCE</a></li><li><a href="global.html#FEATURES">FEATURES</a></li><li><a href="global.html#LIBRARY_INFO">LIBRARY_INFO</a></li><li><a href="global.html#NETWORKS">NETWORKS</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">src/bip/bip32/master-key.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview BIP32 master key generation from seed
 * @version 2.1.0
 * @author yfbsei
 * @license ISC
 */

import { createHmac, randomBytes } from 'node:crypto';
import { secp256k1 } from '@noble/curves/secp256k1';
import { b58encode } from '../../encoding/base58.js';
import {
  CRYPTO_CONSTANTS,
  BIP32_CONSTANTS,
  NETWORK_VERSIONS,
  validateAndGetNetwork
} from '../../core/constants.js';

function secureClear(buffer) {
  if (Buffer.isBuffer(buffer)) {
    const randomData = randomBytes(buffer.length);
    randomData.copy(buffer);
    buffer.fill(0);
  }
}

function validateSeed(seed) {
  if (!seed) {
    throw new Error('Seed is required');
  }

  let seedBuffer;
  if (typeof seed === 'string') {
    seedBuffer = Buffer.from(seed, 'hex');
  } else if (Buffer.isBuffer(seed)) {
    seedBuffer = seed;
  } else {
    throw new Error('Seed must be a Buffer or hex string');
  }

  if (seedBuffer.length &lt; BIP32_CONSTANTS.MIN_SEED_BYTES) {
    throw new Error(`Seed too short: ${seedBuffer.length} &lt; ${BIP32_CONSTANTS.MIN_SEED_BYTES} bytes`);
  }

  if (seedBuffer.length > BIP32_CONSTANTS.MAX_SEED_BYTES) {
    throw new Error(`Seed too long: ${seedBuffer.length} > ${BIP32_CONSTANTS.MAX_SEED_BYTES} bytes`);
  }

  return seedBuffer;
}

function encodeExtendedKey(type, context) {
  const buffer = Buffer.alloc(BIP32_CONSTANTS.EXTENDED_KEY_LENGTH);
  let offset = 0;

  const versionBytes = type === 'private'
    ? context.versionBytes.extendedPrivateKey
    : context.versionBytes.extendedPublicKey;

  versionBytes.copy(buffer, offset);
  offset += 4;

  buffer.writeUInt8(context.depth, offset);
  offset += 1;

  context.parentFingerprint.copy(buffer, offset);
  offset += 4;

  buffer.writeUInt32BE(context.childIndex, offset);
  offset += 4;

  context.chainCode.copy(buffer, offset);
  offset += 32;

  if (type === 'private') {
    buffer.writeUInt8(0x00, offset);
    offset += 1;
    context.privateKey.keyMaterial.copy(buffer, offset);
  } else {
    context.publicKey.keyMaterial.copy(buffer, offset);
  }

  return b58encode(buffer);
}

function generateMasterKey(seed, network = 'main') {
  const seedBuffer = validateSeed(seed);
  const networkConfig = validateAndGetNetwork(network);

  const curveOrder = BigInt('0x' + CRYPTO_CONSTANTS.SECP256K1_ORDER);
  let hmacResult, masterKeyMaterial, chainCode;
  let attemptCount = 0;
  const maxAttempts = 5;

  while (attemptCount &lt; maxAttempts) {
    attemptCount++;

    const hmac = createHmac('sha512', BIP32_CONSTANTS.MASTER_KEY_HMAC_KEY);
    hmacResult = hmac.update(seedBuffer).digest();

    masterKeyMaterial = hmacResult.slice(0, 32);
    chainCode = hmacResult.slice(32, 64);

    const keyBigInt = BigInt('0x' + masterKeyMaterial.toString('hex'));

    if (keyBigInt > 0n &amp;&amp; keyBigInt &lt; curveOrder) {
      break;
    }

    if (attemptCount >= maxAttempts) {
      throw new Error('Failed to generate valid master key after maximum attempts');
    }

    const hmacForSeed = createHmac('sha256', seedBuffer);
    const newSeed = hmacForSeed.update(Buffer.from([attemptCount])).digest();
    seedBuffer.fill(0);
    newSeed.copy(seedBuffer, 0, 0, Math.min(newSeed.length, seedBuffer.length));

    secureClear(masterKeyMaterial);
    secureClear(chainCode);
    secureClear(hmacResult);
  }

  const compressedPublicKey = Buffer.from(secp256k1.getPublicKey(masterKeyMaterial, true));
  const publicKeyPoint = secp256k1.ProjectivePoint.fromPrivateKey(masterKeyMaterial);

  const masterKeyContext = {
    versionBytes: {
      extendedPublicKey: networkConfig.versions.EXTENDED_PUBLIC_KEY,
      extendedPrivateKey: networkConfig.versions.EXTENDED_PRIVATE_KEY
    },
    depth: BIP32_CONSTANTS.MASTER_KEY_DEPTH,
    parentFingerprint: BIP32_CONSTANTS.ZERO_PARENT_FINGERPRINT,
    childIndex: BIP32_CONSTANTS.MASTER_CHILD_INDEX,
    chainCode: chainCode,
    privateKey: {
      keyMaterial: masterKeyMaterial,
      wifVersionByte: networkConfig.versions.WIF_PRIVATE_KEY
    },
    publicKey: {
      keyMaterial: compressedPublicKey,
      point: publicKeyPoint
    }
  };

  const extendedPrivateKey = encodeExtendedKey('private', masterKeyContext);
  const extendedPublicKey = encodeExtendedKey('public', masterKeyContext);

  const expectedPrefix = network === 'main' ? 'xprv' : 'tprv';
  if (!extendedPrivateKey.startsWith(expectedPrefix)) {
    throw new Error(`Invalid extended key prefix: expected ${expectedPrefix}`);
  }

  return [
    {
      extendedPrivateKey,
      extendedPublicKey
    },
    masterKeyContext
  ];
}

export { generateMasterKey, encodeExtendedKey, validateSeed };
export default generateMasterKey;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Tue Dec 30 2025 14:53:38 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
