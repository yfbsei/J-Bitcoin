<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/wallet/custodial.js - J-Bitcoin - Bitcoin Wallet Library</title>
    
    <meta name="description" content="JavaScript/TypeScript Bitcoin wallet library with HD wallets, threshold signatures, and BIP compliance" />
    
        <meta name="keywords" content="bitcoin, btc, cryptocurrency, wallet, javascript, typescript, threshold signatures, bip32, bip39" />
        <meta name="keyword" content="bitcoin, btc, cryptocurrency, wallet, javascript, typescript, threshold signatures, bip32, bip39" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin" target="_blank" class="menu-item home-link" id="home-link" >üè† Home</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin" target="_blank" class="menu-item github-link" id="github-link" >üìö GitHub</a></h2><h2><a href="https://www.npmjs.com/package/j-bitcoin" target="_blank" class="menu-item npm-link" id="npm-link" >üì¶ NPM</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin/tree/main/examples" target="_blank" class="menu-item examples-link" id="examples-link" >üîß Examples</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin/blob/main/CHANGELOG.md" target="_blank" class="menu-item changelog-link" id="changelog-link" >üìä Changelog</a></h2><h3>Global</h3><ul><li><a href="global.html#BIP_COMPLIANCE">BIP_COMPLIANCE</a></li><li><a href="global.html#FEATURES">FEATURES</a></li><li><a href="global.html#LIBRARY_INFO">LIBRARY_INFO</a></li><li><a href="global.html#NETWORKS">NETWORKS</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">src/wallet/custodial.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Custodial Bitcoin Wallet implementation
 * @version 2.0.0
 * @author yfbsei
 * @license ISC
 */

import { createHash } from 'node:crypto';
import { BIP39 } from '../bip/bip39/mnemonic.js';
import { generateMasterKey } from '../bip/bip32/master-key.js';
import { derive } from '../bip/bip32/derive.js';
import { BECH32 } from '../bip/BIP173-BIP350.js';
import { ECDSA } from '../core/crypto/signatures/ecdsa.js';
import { encodeP2PKH, encodeWIF, hash160 } from '../encoding/address/encode.js';
import { NETWORK_VERSIONS, BIP_PURPOSES, generateDerivationPath } from '../core/constants.js';

class CustodialWalletError extends Error {
  constructor(message, solution = '') {
    super(message);
    this.name = 'CustodialWalletError';
    this.solution = solution;
    this.timestamp = new Date().toISOString();
  }
}

class CustodialWallet {
  constructor(network, masterKeys, mnemonic = null) {
    this.network = network === 'main' ? 'main' : 'test';
    this.masterKeys = masterKeys;
    this.mnemonic = mnemonic;
    this.derivedAddresses = new Map();
    this.version = '2.0.0';
    this.created = Date.now();
  }

  static createNew(network = 'main') {
    try {
      const mnemonicResult = BIP39.generateMnemonic();
      const mnemonic = mnemonicResult.mnemonic;
      const seed = BIP39.deriveSeed(mnemonic);
      const [masterKeys] = generateMasterKey(seed, network);

      const wallet = new CustodialWallet(network, masterKeys, mnemonic);
      return { wallet, mnemonic };
    } catch (error) {
      throw new CustodialWalletError(
        `Failed to create wallet: ${error.message}`,
        'Ensure crypto module is available'
      );
    }
  }

  static fromMnemonic(network, mnemonic) {
    try {
      if (!BIP39.validateChecksum(mnemonic)) {
        throw new Error('Invalid mnemonic checksum');
      }

      const seed = BIP39.deriveSeed(mnemonic);
      const [masterKeys] = generateMasterKey(seed, network);

      return new CustodialWallet(network, masterKeys, mnemonic);
    } catch (error) {
      throw new CustodialWalletError(
        `Failed to restore wallet: ${error.message}`,
        'Verify mnemonic phrase is correct'
      );
    }
  }

  static fromSeed(network, seed) {
    try {
      const [masterKeys] = generateMasterKey(seed, network);
      return new CustodialWallet(network, masterKeys, null);
    } catch (error) {
      throw new CustodialWalletError(
        `Failed to create wallet from seed: ${error.message}`,
        'Verify seed is valid hex string'
      );
    }
  }

  static fromExtendedKey(network, extendedKey) {
    try {
      const masterKeys = {
        extendedPrivateKey: extendedKey.startsWith('xprv') || extendedKey.startsWith('tprv')
          ? extendedKey
          : null,
        extendedPublicKey: extendedKey.startsWith('xpub') || extendedKey.startsWith('tpub')
          ? extendedKey
          : null
      };

      if (!masterKeys.extendedPrivateKey &amp;&amp; !masterKeys.extendedPublicKey) {
        throw new Error('Invalid extended key format');
      }

      return new CustodialWallet(network, masterKeys, null);
    } catch (error) {
      throw new CustodialWalletError(
        `Failed to create wallet from extended key: ${error.message}`,
        'Verify extended key format'
      );
    }
  }

  deriveAddress(account = 0, change = 0, index = 0, type = 'segwit') {
    const cacheKey = `${type}:${account}:${change}:${index}`;

    if (this.derivedAddresses.has(cacheKey)) {
      return this.derivedAddresses.get(cacheKey);
    }

    let purpose;
    switch (type) {
      case 'legacy':
        purpose = BIP_PURPOSES.LEGACY;
        break;
      case 'taproot':
        purpose = BIP_PURPOSES.TAPROOT;
        break;
      case 'segwit':
      default:
        purpose = BIP_PURPOSES.NATIVE_SEGWIT;
    }

    const coinType = this.network === 'main' ? 0 : 1;
    const path = `m/${purpose}'/${coinType}'/${account}'/${change}/${index}`;

    const derived = derive(path, this.masterKeys.extendedPrivateKey);
    const publicKeyHex = derived.publicKey.toString('hex');

    let address;
    switch (type) {
      case 'legacy':
        address = encodeP2PKH(derived.publicKey, this.network);
        break;
      case 'taproot':
        const xOnlyPubKey = derived.publicKey.slice(1);
        address = BECH32.to_P2TR(xOnlyPubKey, this.network);
        break;
      case 'segwit':
      default:
        address = BECH32.to_P2WPKH(publicKeyHex, this.network);
    }

    const result = {
      address,
      publicKey: publicKeyHex,
      privateKey: derived.privateKey ? encodeWIF(derived.privateKey, this.network) : null,
      path,
      type,
      network: this.network
    };

    this.derivedAddresses.set(cacheKey, result);
    return result;
  }

  getReceivingAddress(account = 0, index = 0, type = 'segwit') {
    return this.deriveAddress(account, 0, index, type);
  }

  getChangeAddress(account = 0, index = 0, type = 'segwit') {
    return this.deriveAddress(account, 1, index, type);
  }

  signMessage(message, account = 0, index = 0) {
    const derived = this.deriveAddress(account, 0, index, 'segwit');

    if (!derived.privateKey) {
      throw new CustodialWalletError('No private key available for signing');
    }

    return ECDSA.signMessage(derived.privateKey, message);
  }

  verifyMessage(message, signature, publicKey) {
    return ECDSA.verifyMessage(signature, message, publicKey);
  }

  getExtendedPublicKey() {
    return this.masterKeys.extendedPublicKey;
  }

  getExtendedPrivateKey() {
    return this.masterKeys.extendedPrivateKey;
  }

  getMnemonic() {
    return this.mnemonic;
  }

  getNetwork() {
    return this.network;
  }

  toJSON() {
    return {
      network: this.network,
      version: this.version,
      created: this.created,
      extendedPublicKey: this.masterKeys.extendedPublicKey,
      addressCount: this.derivedAddresses.size
    };
  }

  clearCache() {
    this.derivedAddresses.clear();
  }
}

export { CustodialWallet, CustodialWalletError };
export default CustodialWallet;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Tue Dec 30 2025 14:53:38 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
