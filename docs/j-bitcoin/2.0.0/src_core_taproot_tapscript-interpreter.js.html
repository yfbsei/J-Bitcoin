<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/core/taproot/tapscript-interpreter.js - J-Bitcoin - Bitcoin Wallet Library</title>
    
    <meta name="description" content="JavaScript/TypeScript Bitcoin wallet library with HD wallets, threshold signatures, and BIP compliance" />
    
        <meta name="keywords" content="bitcoin, btc, cryptocurrency, wallet, javascript, typescript, threshold signatures, bip32, bip39" />
        <meta name="keyword" content="bitcoin, btc, cryptocurrency, wallet, javascript, typescript, threshold signatures, bip32, bip39" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin" target="_blank" class="menu-item home-link" id="home-link" >üè† Home</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin" target="_blank" class="menu-item github-link" id="github-link" >üìö GitHub</a></h2><h2><a href="https://www.npmjs.com/package/j-bitcoin" target="_blank" class="menu-item npm-link" id="npm-link" >üì¶ NPM</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin/tree/main/examples" target="_blank" class="menu-item examples-link" id="examples-link" >üîß Examples</a></h2><h2><a href="https://github.com/yfbsei/J-Bitcoin/blob/main/CHANGELOG.md" target="_blank" class="menu-item changelog-link" id="changelog-link" >üìä Changelog</a></h2><h3>Global</h3><ul><li><a href="global.html#BIP_COMPLIANCE">BIP_COMPLIANCE</a></li><li><a href="global.html#FEATURES">FEATURES</a></li><li><a href="global.html#LIBRARY_INFO">LIBRARY_INFO</a></li><li><a href="global.html#NETWORKS">NETWORKS</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">src/core/taproot/tapscript-interpreter.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Tapscript interpreter implementation following BIP342
 * @version 2.1.0
 * @author yfbsei
 * @license ISC
 */

import { createHash, randomBytes } from 'node:crypto';
import Schnorr from '../crypto/signatures/schnorr-BIP340.js';
import { CRYPTO_CONSTANTS } from '../constants.js';

class TapscriptError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'TapscriptError';
    this.code = code;
    this.details = details;
  }
}

const TAPSCRIPT_CONSTANTS = {
  MAX_STACK_SIZE: 1000,
  MAX_SCRIPT_SIZE: 10000,
  MAX_ELEMENT_SIZE: 520,
  MAX_OPS_PER_SCRIPT: 201,
  BASE_SIGOPS_BUDGET: 50,
  SIGOPS_PER_WITNESS_UNIT: 1,
  LEAF_VERSION_TAPSCRIPT: 0xc0,
  MAX_SCRIPT_NUM_SIZE: 4,
  MAX_PUBKEYS_PER_MULTISIG: 20
};

const OPCODES = {
  OP_0: 0x00,
  OP_PUSHDATA1: 0x4c,
  OP_PUSHDATA2: 0x4d,
  OP_PUSHDATA4: 0x4e,
  OP_1NEGATE: 0x4f,
  OP_1: 0x51,
  OP_16: 0x60,
  OP_NOP: 0x61,
  OP_IF: 0x63,
  OP_NOTIF: 0x64,
  OP_ELSE: 0x67,
  OP_ENDIF: 0x68,
  OP_VERIFY: 0x69,
  OP_RETURN: 0x6a,
  OP_DUP: 0x76,
  OP_EQUAL: 0x87,
  OP_EQUALVERIFY: 0x88,
  OP_HASH160: 0xa9,
  OP_HASH256: 0xaa,
  OP_CHECKSIG: 0xac,
  OP_CHECKSIGVERIFY: 0xad,
  OP_CHECKMULTISIG: 0xae,
  OP_CHECKSIGADD: 0xba,
  OP_SUCCESS_START: 0x50,
  OP_SUCCESS_END: 0xfe
};

class ScriptNum {
  static decode(buffer) {
    if (buffer.length === 0) return 0;

    if (buffer.length > TAPSCRIPT_CONSTANTS.MAX_SCRIPT_NUM_SIZE) {
      throw new TapscriptError('Script number too large', 'NUMBER_TOO_LARGE');
    }

    let result = 0;
    for (let i = 0; i &lt; buffer.length; i++) {
      result |= buffer[i] &lt;&lt; (8 * i);
    }

    if (buffer[buffer.length - 1] &amp; 0x80) {
      result = -(result &amp; ~(0x80 &lt;&lt; (8 * (buffer.length - 1))));
    }

    return result;
  }

  static encode(num) {
    if (num === 0) return Buffer.alloc(0);

    const negative = num &lt; 0;
    let absValue = Math.abs(num);
    const result = [];

    while (absValue > 0) {
      result.push(absValue &amp; 0xff);
      absValue >>= 8;
    }

    if (result[result.length - 1] &amp; 0x80) {
      result.push(negative ? 0x80 : 0x00);
    } else if (negative) {
      result[result.length - 1] |= 0x80;
    }

    return Buffer.from(result);
  }
}

class TapscriptInterpreter {
  constructor() {
    this.schnorrValidator = new Schnorr();
  }

  async execute(script, witness, context = {}) {
    const executionContext = {
      stack: [],
      altStack: [],
      opCount: 0,
      sigOpsCount: 0,
      sigOpsBudget: this._calculateSigOpsBudget(witness),
      conditionStack: [],
      script: Buffer.isBuffer(script) ? script : Buffer.from(script),
      witness: witness || [],
      ...context
    };

    for (const item of executionContext.witness) {
      executionContext.stack.push(item);
    }

    let offset = 0;
    while (offset &lt; executionContext.script.length) {
      const opcode = executionContext.script[offset];
      offset++;

      if (this._isOpSuccess(opcode)) {
        return { success: true, reason: 'OP_SUCCESS' };
      }

      if (opcode >= 0x01 &amp;&amp; opcode &lt;= 0x4b) {
        const data = executionContext.script.slice(offset, offset + opcode);
        offset += opcode;
        executionContext.stack.push(data);
        continue;
      }

      await this._executeOpcode(opcode, executionContext, offset);
      this._checkLimits(executionContext);
    }

    return this._evaluateResult(executionContext);
  }

  _calculateSigOpsBudget(witness) {
    const witnessSize = witness.reduce((sum, item) => sum + item.length, 0);
    return TAPSCRIPT_CONSTANTS.BASE_SIGOPS_BUDGET +
           Math.floor(witnessSize / TAPSCRIPT_CONSTANTS.SIGOPS_PER_WITNESS_UNIT);
  }

  _isOpSuccess(opcode) {
    if (opcode === 0x50) return true;
    if (opcode === 0x62) return true;
    if (opcode === 0x89) return true;
    if (opcode === 0x8a) return true;
    if (opcode >= 0x8d &amp;&amp; opcode &lt;= 0x8e) return true;
    if (opcode >= 0x95 &amp;&amp; opcode &lt;= 0x99) return true;
    if (opcode >= 0xbb &amp;&amp; opcode &lt;= 0xfe) return true;
    return false;
  }

  async _executeOpcode(opcode, context) {
    context.opCount++;

    switch (opcode) {
      case OPCODES.OP_0:
        context.stack.push(Buffer.alloc(0));
        break;

      case OPCODES.OP_DUP:
        if (context.stack.length &lt; 1) {
          throw new TapscriptError('Stack underflow', 'STACK_UNDERFLOW');
        }
        context.stack.push(Buffer.from(context.stack[context.stack.length - 1]));
        break;

      case OPCODES.OP_EQUAL:
        this._executeEqual(context);
        break;

      case OPCODES.OP_EQUALVERIFY:
        this._executeEqual(context);
        if (!this._isTruthy(context.stack.pop())) {
          throw new TapscriptError('EQUALVERIFY failed', 'VERIFY_FAILED');
        }
        break;

      case OPCODES.OP_VERIFY:
        if (context.stack.length &lt; 1) {
          throw new TapscriptError('Stack underflow', 'STACK_UNDERFLOW');
        }
        if (!this._isTruthy(context.stack.pop())) {
          throw new TapscriptError('VERIFY failed', 'VERIFY_FAILED');
        }
        break;

      case OPCODES.OP_CHECKSIG:
        await this._executeChecksig(context, context.sigHash);
        break;

      case OPCODES.OP_CHECKSIGVERIFY:
        await this._executeChecksig(context, context.sigHash);
        if (!this._isTruthy(context.stack.pop())) {
          throw new TapscriptError('CHECKSIGVERIFY failed', 'VERIFY_FAILED');
        }
        break;

      case OPCODES.OP_CHECKSIGADD:
        await this._executeChecksigAdd(context, context.sigHash);
        break;

      default:
        if (opcode >= OPCODES.OP_1 &amp;&amp; opcode &lt;= OPCODES.OP_16) {
          context.stack.push(Buffer.from([opcode - OPCODES.OP_1 + 1]));
        }
    }
  }

  _executeEqual(context) {
    if (context.stack.length &lt; 2) {
      throw new TapscriptError('Stack underflow', 'STACK_UNDERFLOW');
    }
    const b = context.stack.pop();
    const a = context.stack.pop();
    context.stack.push(a.equals(b) ? Buffer.from([0x01]) : Buffer.alloc(0));
  }

  async _executeChecksig(context, sigHash) {
    if (context.stack.length &lt; 2) {
      throw new TapscriptError('Stack underflow', 'STACK_UNDERFLOW');
    }

    const pubkey = context.stack.pop();
    const signature = context.stack.pop();

    context.sigOpsCount++;
    this._checkBudgets(context);

    if (signature.length === 0) {
      context.stack.push(Buffer.alloc(0));
      return;
    }

    if (signature.length !== 64 || pubkey.length !== 32) {
      context.stack.push(Buffer.alloc(0));
      return;
    }

    try {
      const isValid = await this.schnorrValidator.verify(signature, sigHash, pubkey);
      context.stack.push(isValid ? Buffer.from([0x01]) : Buffer.alloc(0));
    } catch {
      context.stack.push(Buffer.alloc(0));
    }
  }

  async _executeChecksigAdd(context, sigHash) {
    if (context.stack.length &lt; 3) {
      throw new TapscriptError('Stack underflow', 'STACK_UNDERFLOW');
    }

    const pubkey = context.stack.pop();
    const num = context.stack.pop();
    const signature = context.stack.pop();

    context.sigOpsCount++;
    this._checkBudgets(context);

    let n = ScriptNum.decode(num);
    let isValid = false;

    if (signature.length !== 0 &amp;&amp; signature.length === 64 &amp;&amp; pubkey.length === 32) {
      try {
        isValid = await this.schnorrValidator.verify(signature, sigHash, pubkey);
      } catch {
        isValid = false;
      }
    }

    const result = n + (isValid ? 1 : 0);
    context.stack.push(ScriptNum.encode(result));
  }

  _checkLimits(context) {
    if (context.stack.length > TAPSCRIPT_CONSTANTS.MAX_STACK_SIZE) {
      throw new TapscriptError('Stack size exceeded', 'STACK_OVERFLOW');
    }

    if (context.opCount > TAPSCRIPT_CONSTANTS.MAX_OPS_PER_SCRIPT) {
      throw new TapscriptError('Op count exceeded', 'OP_COUNT_EXCEEDED');
    }
  }

  _checkBudgets(context) {
    if (context.sigOpsCount > context.sigOpsBudget) {
      throw new TapscriptError('Signature operations budget exceeded', 'SIGOPS_EXCEEDED');
    }
  }

  _isTruthy(value) {
    if (!value || value.length === 0) return false;
    for (let i = 0; i &lt; value.length; i++) {
      if (value[i] !== 0) {
        if (i === value.length - 1 &amp;&amp; value[i] === 0x80) continue;
        return true;
      }
    }
    return false;
  }

  _evaluateResult(context) {
    if (context.stack.length === 0) {
      return { success: false, reason: 'Empty stack' };
    }

    const topElement = context.stack[context.stack.length - 1];
    return {
      success: this._isTruthy(topElement),
      stack: context.stack,
      opCount: context.opCount,
      sigOpsCount: context.sigOpsCount
    };
  }
}

export {
  TapscriptInterpreter,
  TapscriptError,
  TAPSCRIPT_CONSTANTS,
  OPCODES,
  ScriptNum
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Tue Dec 30 2025 14:53:38 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
